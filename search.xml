<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>react</title>
      <link href="/2024/02/23/hello-world/"/>
      <url>/2024/02/23/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="对React的理解和特性"><a href="#对React的理解和特性" class="headerlink" title="对React的理解和特性"></a>对React的理解和特性</h1><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>React 是一个用于构建用户界面的JavaScript 库。它是由 Facebook 开发并开源的，并且现在是前端开发领域最受欢迎和广泛使用的库之一。提供了UI层面的解决方案</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li><p><strong>组件化</strong>：React 鼓励将用户界面划分为可重用的组件。每个组件都有自己的状态和属性，并且可以通过组合和嵌套来构建复杂的界面。</p></li><li><p><strong>虚拟 DOM</strong>：React 使用虚拟 DOM（Virtual DOM）来提高性能。整个界面会被表示为一个虚拟 DOM 树，React 会比较前后两个虚拟 DOM 树的差异，并最小化真实 DOM 的操作来更新界面，从而减少了直接操作 DOM 的开销。</p></li><li><p><strong>单向数据流</strong>：React 推崇单向数据流，数据的流动是单向的，从父组件流向子组件。这种数据流动的方式使得状态管理更加可控和可预测。</p></li><li><p><strong>生命周期方法</strong>：React 组件有一组生命周期方法，可以在组件的不同阶段执行特定的操作。这些方法可以用于初始化组件、更新组件状态、处理事件等。</p></li><li><p><strong>JSX</strong>：JSX 是一种将 HTML 与 JavaScript 结合的语法扩展，它允许我们直接在 JavaScript 代码中编写类似于 HTML 的结构。JSX 使得组件的编写更加直观、简洁，并且易于阅读和维护。</p></li><li><p><strong>高性能</strong>：通过使用虚拟 DOM 和按需更新的方式，以及其他一些优化技术，React 能够高效地处理大型和复杂的用户界面，提供出色的性能表现。</p></li><li><p><strong>声明式编程</strong>：声明式编程是一种编程范式，它强调编写代码时关注描述问题是什么，而不是如何解决问题。在声明式编程中，开发者只需要定义所需的状态、数据和逻辑，而不需要关注如何实现它们。</p></li></ol><p>这些只是 React 的一些主要特性，React 还有许多其他的功能和扩展，例如状态管理库（如Redux、Mobx）、React Router 进行路由管理等。React 的设计哲学是灵活和可组合的，可以与其他库和工具无缝集成，使得前端开发更加高效和便捷。</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li>高效：对DOM模拟 不直接操作DOM</li><li>灵活：和已知的库或者框架很好的配合</li><li>跨浏览器兼容</li><li>声明式设计</li><li>组件式开发：一切都是component 提高复用率</li><li>单向数据流</li></ul><h1 id="区别-State（状态）和-Props（属性）"><a href="#区别-State（状态）和-Props（属性）" class="headerlink" title="区别 State（状态）和 Props（属性）"></a>区别 State（状态）和 Props（属性）</h1><p><strong>State（状态）</strong> 是组件内部管理的可变数据。它是组件独有的数据，可以通过 <code>this.state</code> 来访问和更新。State 可以在组件的生命周期中根据需要进行更新，当 state 发生改变时，React 会自动重新渲染相应的组件部分。State 通常用于存储和管理组件的状态变化，比如可通过用户交互或异步操作发生变化的数据。</p><p><strong>Props（属性）</strong> 是组件之间传递的数据。它是组件外部传递给组件的数据，类似于函数的参数。Props 是只读的，只能从父组件传递给子组件，并且子组件无法直接修改 Props 的值。通过在组件定义中使用 <code>this.props</code> 可以访问 Props 的值。Props 通常用于父组件向子组件传递数据和配置信息，以及触发父组件中的事件。</p><p><strong>相同点：</strong></p><ul><li>两者都是js对象</li><li>两者都是用来保存信息</li><li>props 和 state 都能触发渲染更新</li></ul><p><strong>不同点：</strong></p><ul><li>props 外部方式传递给组件 state 组件内自己管理维护</li><li>props 组件内不可修改 state 组件内可修改</li><li>state 是多变的 可以修改</li></ul><p>在 React 应用中，通过合理使用 State 和 Props，可以实现动态交互和数据流动，构建灵活且可复用的组件。</p><h1 id="区别-super-和-super-props"><a href="#区别-super-和-super-props" class="headerlink" title="区别 super() 和 super(props)"></a>区别 super() 和 super(props)</h1><p>在 React 组件的构造函数中，通常会调用 <code>super()</code> 或 <code>super(props)</code>，它们有一些不同之处。</p><ul><li><p>**super()**：在构造函数中调用 <code>super()</code> 表示调用父类的构造函数，而没有传递任何参数。这样做的目的是确保在子类构造函数中能够访问到父类的属性和方法。通常情况下，如果不需要在构造函数中使用到 <code>this.props</code>，那么可以直接使用 <code>super()</code> 调用父类构造函数。</p></li><li><p>**super(props)**：在构造函数中调用 <code>super(props)</code> 表示调用父类的构造函数，并将 <code>props</code> 作为参数传递给父类构造函数。通过传递 <code>props</code> 参数，子类构造函数可以在构造阶段访问到组件的属性。这种情况下，如果需要在构造函数中使用 <code>this.props</code>，则需要使用 <code>super(props)</code> 来传递属性给父类构造函数。</p></li></ul><p>总结而言：</p><ul><li><code>super()</code> 是用于在子类构造函数中调用父类构造函数，不传递任何参数。</li><li><code>super(props)</code> 是用于在子类构造函数中调用父类构造函数，并传递 <code>props</code> 参数。</li></ul><p>在 React 组件开发中，通常使用 <code>super(props)</code> 来访问 <code>this.props</code>，以便在组件构造阶段能够正确地处理属性。</p><h1 id="类组件和函数组件"><a href="#类组件和函数组件" class="headerlink" title="类组件和函数组件"></a>类组件和函数组件</h1><p><strong>类组件</strong>：</p><ul><li>类组件是使用 ES6 class 语法定义的组件，继承自 React.Component 类。</li><li>类组件拥有自己的状态（state）和生命周期方法，可以通过 this.state 和 this.setState() 进行状态管理。</li><li>适合复杂的组件逻辑，例如包含大量状态管理、生命周期方法和事件处理逻辑的组件。</li></ul><p><strong>函数组件</strong>：</p><ul><li>函数组件是使用函数定义的无状态组件，是纯粹的 JavaScript 函数，接收 props 作为参数并返回 JSX 元素。</li><li>函数组件没有自己的状态和生命周期方法，只能通过 React Hooks 来实现状态管理（在 React 16.8 之后引入）。</li><li>适合简单的展示型组件，例如只包含简单渲染逻辑的无状态组件。</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li>语法：类组件使用 class 语法，函数组件使用函数语法。</li><li>状态管理：类组件有自己的状态和生命周期方法，而函数组件需要使用 React Hooks 来管理状态。</li><li>复杂性：类组件适合逻辑复杂的组件，函数组件适合简单的展示型组件。</li><li>操作实例：类组件可以使用 this 来操作实例，而函数组件没有实例的概念。</li></ol><p>总的来说，随着 React Hooks 的出现，函数组件越来越强大，可以替代大部分的类组件。在开发新的组件时，推荐优先选择函数组件，除非需要使用类组件特有的功能。</p><h1 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="headerlink" title="受控组件和非受控组件"></a>受控组件和非受控组件</h1><p><strong>受控组件</strong>：</p><ul><li>受控组件是由 React 来管理并控制表单元素的值和状态。</li><li>通过在组件的状态或属性中存储表单元素的值，并在事件处理程序中更新状态，实现对表单元素的控制。</li><li>可以通过事件处理程序来检验、处理用户输入，提供更精确的控制和验证。</li></ul><p><strong>非受控组件</strong>：</p><ul><li>非受控组件将表单元素的值交由 DOM 自身来处理，不受 React 直接控制。</li><li>通过直接操作真实 DOM 元素，获取和处理表单数据。</li><li>通常适用于简单的表单场景，或者只需要获取表单值而不需要进行复杂处理和校验的情况。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>受控组件</strong>：</p><ul><li>当需要对表单数据进行验证、处理和控制时，尤其是在复杂的表单场景下，使用受控组件是较为合适的选择。</li><li>受控组件可以精确控制表单数据流，可以通过 state 或 props 来存储和更新表单元素的值，方便进行数据校验和处理。</li></ul><p><strong>非受控组件</strong>：</p><ul><li>ref</li><li>当表单简单且只需要获取表单的值时，使用非受控组件可以简化开发和代码量。</li><li>非受控组件省去了对表单数据进行状态管理的步骤，通过直接操作 DOM 元素来获取表单值，适用于一些简单的、不需要复杂处理的表单场景。</li></ul><p>在具体应用中，开发者需要根据实际需求来选择使用受控组件还是非受控组件，权衡开发复杂性和表单控制的需求。</p><h1 id="React-的事件机制"><a href="#React-的事件机制" class="headerlink" title="React 的事件机制"></a>React 的事件机制</h1><p>React 使用了一种合成事件（SyntheticEvent）机制，将浏览器原生事件进行了封装和统一处理，提供了跨浏览器的事件兼容性和其他一些便利功能。以下是 React 事件机制的一些要点：</p><ul><li><p><strong>合成事件</strong>：React 事件机制封装了浏览器原生事件，统一了事件的触发和处理方式。开发者不需要直接操作 DOM 来绑定事件监听器，而是在 React 组件上使用类似于原生的 onXxx&#x3D;{handler} 语法来注册事件处理函数。</p></li><li><p><strong>事件处理函数</strong>：在 React 组件中，事件处理函数是普通的 JavaScript 函数，定义在组件类或函数组件内部，并被赋值给相应的事件属性。例如，onClick&#x3D;{handleClick} 可以用于处理点击事件。</p></li><li><p><strong>事件传播和阻止默认行为</strong>：React 的事件机制也支持事件传播（冒泡）和阻止默认行为。在事件处理函数中可以使用 event.stopPropagation() 来停止事件继续冒泡，使用 event.preventDefault() 来阻止浏览器默认行为。</p></li><li><p><strong>事件参数</strong>：事件处理函数的参数是一个合成事件对象（SyntheticEvent），它是 React 封装的一个跨浏览器的事件对象，提供了一些常用的事件属性和方法。例如，event.target 可以获取触发事件的 DOM 元素。</p></li><li><p><strong>异步事件处理</strong>：React 的事件机制使用了事件委托的方式，将事件交由顶层容器处理。因此，React 的事件是异步执行的，而不是在事件发生时立即触发。这样的设计有助于提升性能和优化事件处理过程。</p></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>React 所有事件都挂载在 document 对象上，先触发真实DOM事件 再触发 React 事件，最后真正执行 document 上挂载的事件</p></li><li><p>由于 React 使用了合成事件机制，所以在事件处理函数中不能直接使用 event.nativeEvent 来访问原生事件对象，而要使用 event 对象上的属性和方法。</p></li><li><p>由于事件是异步执行的，如果需要在事件处理函数中获取表单元素的最新值，可以使用传统的 JavaScript 事件对象的属性，如 event.target.value，而不是使用 React 组件的状态（state）。</p></li></ul><p>总的来说，React 的事件机制提供了便捷的事件处理方式，封装了常用的浏览器事件，提供了跨浏览器兼容性和一些额外的功能。开发者可以通过声明式的方式来管理组件的交互行为和数据流动。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
