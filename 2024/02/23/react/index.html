<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>react | Code Chronicles</title><meta name="author" content="皮蛋瘦肉周"><meta name="copyright" content="皮蛋瘦肉周"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="对React的理解和特性理解React 是一个用于构建用户界面的JavaScript 库。它是由 Facebook 开发并开源的，并且现在是前端开发领域最受欢迎和广泛使用的库之一。提供了UI层面的解决方案 特性 组件化：React 鼓励将用户界面划分为可重用的组件。每个组件都有自己的状态和属性，并且可以通过组合和嵌套来构建复杂的界面。  虚拟 DOM：React 使用虚拟 DOM（Virtual">
<meta property="og:type" content="article">
<meta property="og:title" content="react">
<meta property="og:url" content="https://zej574099903.github.io/2024/02/23/react/index.html">
<meta property="og:site_name" content="Code Chronicles">
<meta property="og:description" content="对React的理解和特性理解React 是一个用于构建用户界面的JavaScript 库。它是由 Facebook 开发并开源的，并且现在是前端开发领域最受欢迎和广泛使用的库之一。提供了UI层面的解决方案 特性 组件化：React 鼓励将用户界面划分为可重用的组件。每个组件都有自己的状态和属性，并且可以通过组合和嵌套来构建复杂的界面。  虚拟 DOM：React 使用虚拟 DOM（Virtual">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zej574099903.github.io/img/react.jpg">
<meta property="article:published_time" content="2024-02-23T07:15:55.000Z">
<meta property="article:modified_time" content="2024-02-27T08:06:40.520Z">
<meta property="article:author" content="皮蛋瘦肉周">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zej574099903.github.io/img/react.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zej574099903.github.io/2024/02/23/react/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'react',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-27 16:06:40'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/react.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Code Chronicles"><span class="site-name">Code Chronicles</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">react</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-23T07:15:55.000Z" title="发表于 2024-02-23 15:15:55">2024-02-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-27T08:06:40.520Z" title="更新于 2024-02-27 16:06:40">2024-02-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="react"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="对React的理解和特性"><a href="#对React的理解和特性" class="headerlink" title="对React的理解和特性"></a>对React的理解和特性</h1><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>React 是一个用于构建用户界面的JavaScript 库。它是由 Facebook 开发并开源的，并且现在是前端开发领域最受欢迎和广泛使用的库之一。提供了UI层面的解决方案</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol>
<li><p><strong>组件化</strong>：React 鼓励将用户界面划分为可重用的组件。每个组件都有自己的状态和属性，并且可以通过组合和嵌套来构建复杂的界面。</p>
</li>
<li><p><strong>虚拟 DOM</strong>：React 使用虚拟 DOM（Virtual DOM）来提高性能。整个界面会被表示为一个虚拟 DOM 树，React 会比较前后两个虚拟 DOM 树的差异，并最小化真实 DOM 的操作来更新界面，从而减少了直接操作 DOM 的开销。</p>
</li>
<li><p><strong>单向数据流</strong>：React 推崇单向数据流，数据的流动是单向的，从父组件流向子组件。这种数据流动的方式使得状态管理更加可控和可预测。</p>
</li>
<li><p><strong>生命周期方法</strong>：React 组件有一组生命周期方法，可以在组件的不同阶段执行特定的操作。这些方法可以用于初始化组件、更新组件状态、处理事件等。</p>
</li>
<li><p><strong>JSX</strong>：JSX 是一种将 HTML 与 JavaScript 结合的语法扩展，它允许我们直接在 JavaScript 代码中编写类似于 HTML 的结构。JSX 使得组件的编写更加直观、简洁，并且易于阅读和维护。</p>
</li>
<li><p><strong>高性能</strong>：通过使用虚拟 DOM 和按需更新的方式，以及其他一些优化技术，React 能够高效地处理大型和复杂的用户界面，提供出色的性能表现。</p>
</li>
<li><p><strong>声明式编程</strong>：声明式编程是一种编程范式，它强调编写代码时关注描述问题是什么，而不是如何解决问题。在声明式编程中，开发者只需要定义所需的状态、数据和逻辑，而不需要关注如何实现它们。</p>
</li>
</ol>
<p>这些只是 React 的一些主要特性，React 还有许多其他的功能和扩展，例如状态管理库（如Redux、Mobx）、React Router 进行路由管理等。React 的设计哲学是灵活和可组合的，可以与其他库和工具无缝集成，使得前端开发更加高效和便捷。</p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul>
<li>高效：对DOM模拟 不直接操作DOM</li>
<li>灵活：和已知的库或者框架很好的配合</li>
<li>跨浏览器兼容</li>
<li>声明式设计</li>
<li>组件式开发：一切都是component 提高复用率</li>
<li>单向数据流</li>
</ul>
<h1 id="区别-State（状态）和-Props（属性）"><a href="#区别-State（状态）和-Props（属性）" class="headerlink" title="区别 State（状态）和 Props（属性）"></a>区别 State（状态）和 Props（属性）</h1><p><strong>State（状态）</strong> 是组件内部管理的可变数据。它是组件独有的数据，可以通过 <code>this.state</code> 来访问和更新。State 可以在组件的生命周期中根据需要进行更新，当 state 发生改变时，React 会自动重新渲染相应的组件部分。State 通常用于存储和管理组件的状态变化，比如可通过用户交互或异步操作发生变化的数据。</p>
<p><strong>Props（属性）</strong> 是组件之间传递的数据。它是组件外部传递给组件的数据，类似于函数的参数。Props 是只读的，只能从父组件传递给子组件，并且子组件无法直接修改 Props 的值。通过在组件定义中使用 <code>this.props</code> 可以访问 Props 的值。Props 通常用于父组件向子组件传递数据和配置信息，以及触发父组件中的事件。</p>
<p><strong>相同点：</strong></p>
<ul>
<li>两者都是js对象</li>
<li>两者都是用来保存信息</li>
<li>props 和 state 都能触发渲染更新</li>
</ul>
<p><strong>不同点：</strong></p>
<ul>
<li>props 外部方式传递给组件 state 组件内自己管理维护</li>
<li>props 组件内不可修改 state 组件内可修改</li>
<li>state 是多变的 可以修改</li>
</ul>
<h1 id="区别-super-和-super-props"><a href="#区别-super-和-super-props" class="headerlink" title="区别 super() 和 super(props)"></a>区别 super() 和 super(props)</h1><p>在 React 组件的构造函数中，通常会调用 <code>super()</code> 或 <code>super(props)</code>，它们有一些不同之处。</p>
<ul>
<li><p>**super()**：在构造函数中调用 <code>super()</code> 表示调用父类的构造函数，而没有传递任何参数。这样做的目的是确保在子类构造函数中能够访问到父类的属性和方法。通常情况下，如果不需要在构造函数中使用到 <code>this.props</code>，那么可以直接使用 <code>super()</code> 调用父类构造函数。</p>
</li>
<li><p>**super(props)**：在构造函数中调用 <code>super(props)</code> 表示调用父类的构造函数，并将 <code>props</code> 作为参数传递给父类构造函数。通过传递 <code>props</code> 参数，子类构造函数可以在构造阶段访问到组件的属性。这种情况下，如果需要在构造函数中使用 <code>this.props</code>，则需要使用 <code>super(props)</code> 来传递属性给父类构造函数。</p>
</li>
</ul>
<p>总结而言：</p>
<ul>
<li><code>super()</code> 是用于在子类构造函数中调用父类构造函数，不传递任何参数。</li>
<li><code>super(props)</code> 是用于在子类构造函数中调用父类构造函数，并传递 <code>props</code> 参数。</li>
</ul>
<p>在 React 组件开发中，通常使用 <code>super(props)</code> 来访问 <code>this.props</code>，以便在组件构造阶段能够正确地处理属性。</p>
<h1 id="类组件和函数组件"><a href="#类组件和函数组件" class="headerlink" title="类组件和函数组件"></a>类组件和函数组件</h1><p><strong>类组件</strong>：</p>
<ul>
<li>类组件是使用 ES6 class 语法定义的组件，继承自 React.Component 类。</li>
<li>类组件拥有自己的状态（state）和生命周期方法，可以通过 this.state 和 this.setState() 进行状态管理。</li>
<li>适合复杂的组件逻辑，例如包含大量状态管理、生命周期方法和事件处理逻辑的组件。</li>
</ul>
<p><strong>函数组件</strong>：</p>
<ul>
<li>函数组件是使用函数定义的无状态组件，是纯粹的 JavaScript 函数，接收 props 作为参数并返回 JSX 元素。</li>
<li>函数组件没有自己的状态和生命周期方法，只能通过 React Hooks 来实现状态管理（在 React 16.8 之后引入）。</li>
<li>适合简单的展示型组件，例如只包含简单渲染逻辑的无状态组件。</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li>语法：类组件使用 class 语法，函数组件使用函数语法。</li>
<li>状态管理：类组件有自己的状态和生命周期方法，而函数组件需要使用 React Hooks 来管理状态。</li>
<li>复杂性：类组件适合逻辑复杂的组件，函数组件适合简单的展示型组件。</li>
<li>操作实例：类组件可以使用 this 来操作实例，而函数组件没有实例的概念。</li>
</ol>
<p>总的来说，随着 React Hooks 的出现，函数组件越来越强大，可以替代大部分的类组件。在开发新的组件时，推荐优先选择函数组件，除非需要使用类组件特有的功能。</p>
<h1 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="headerlink" title="受控组件和非受控组件"></a>受控组件和非受控组件</h1><p><strong>受控组件</strong>：</p>
<ul>
<li>受控组件是由 React 来管理并控制表单元素的值和状态。</li>
<li>通过在组件的状态或属性中存储表单元素的值，并在事件处理程序中更新状态，实现对表单元素的控制。</li>
<li>可以通过事件处理程序来检验、处理用户输入，提供更精确的控制和验证。</li>
</ul>
<p><strong>非受控组件</strong>：</p>
<ul>
<li>非受控组件将表单元素的值交由 DOM 自身来处理，不受 React 直接控制。</li>
<li>通过直接操作真实 DOM 元素，获取和处理表单数据。</li>
<li>通常适用于简单的表单场景，或者只需要获取表单值而不需要进行复杂处理和校验的情况。</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>受控组件</strong>：</p>
<ul>
<li>当需要对表单数据进行验证、处理和控制时，尤其是在复杂的表单场景下，使用受控组件是较为合适的选择。</li>
<li>受控组件可以精确控制表单数据流，可以通过 state 或 props 来存储和更新表单元素的值，方便进行数据校验和处理。</li>
</ul>
<p><strong>非受控组件</strong>：</p>
<ul>
<li>ref</li>
<li>当表单简单且只需要获取表单的值时，使用非受控组件可以简化开发和代码量。</li>
<li>非受控组件省去了对表单数据进行状态管理的步骤，通过直接操作 DOM 元素来获取表单值，适用于一些简单的、不需要复杂处理的表单场景。</li>
</ul>
<p>在具体应用中，开发者需要根据实际需求来选择使用受控组件还是非受控组件，权衡开发复杂性和表单控制的需求。</p>
<h1 id="React-的事件机制"><a href="#React-的事件机制" class="headerlink" title="React 的事件机制"></a>React 的事件机制</h1><p>React 使用了一种合成事件（SyntheticEvent）机制，将浏览器原生事件进行了封装和统一处理，提供了跨浏览器的事件兼容性和其他一些便利功能。以下是 React 事件机制的一些要点：</p>
<ul>
<li><p><strong>合成事件</strong>：React 事件机制封装了浏览器原生事件，统一了事件的触发和处理方式。开发者不需要直接操作 DOM 来绑定事件监听器，而是在 React 组件上使用类似于原生的 onXxx&#x3D;{handler} 语法来注册事件处理函数。</p>
</li>
<li><p><strong>事件处理函数</strong>：在 React 组件中，事件处理函数是普通的 JavaScript 函数，定义在组件类或函数组件内部，并被赋值给相应的事件属性。例如，onClick&#x3D;{handleClick} 可以用于处理点击事件。</p>
</li>
<li><p><strong>事件传播和阻止默认行为</strong>：React 的事件机制也支持事件传播（冒泡）和阻止默认行为。在事件处理函数中可以使用 event.stopPropagation() 来停止事件继续冒泡，使用 event.preventDefault() 来阻止浏览器默认行为。</p>
</li>
<li><p><strong>事件参数</strong>：事件处理函数的参数是一个合成事件对象（SyntheticEvent），它是 React 封装的一个跨浏览器的事件对象，提供了一些常用的事件属性和方法。例如，event.target 可以获取触发事件的 DOM 元素。</p>
</li>
<li><p><strong>异步事件处理</strong>：React 的事件机制使用了事件委托的方式，将事件交由顶层容器处理。因此，React 的事件是异步执行的，而不是在事件发生时立即触发。这样的设计有助于提升性能和优化事件处理过程。</p>
</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><p>React 所有事件都挂载在 document 对象上，先触发真实DOM事件 再触发 React 事件，最后真正执行 document 上挂载的事件</p>
</li>
<li><p>由于 React 使用了合成事件机制，所以在事件处理函数中不能直接使用 event.nativeEvent 来访问原生事件对象，而要使用 event 对象上的属性和方法。</p>
</li>
<li><p>由于事件是异步执行的，如果需要在事件处理函数中获取表单元素的最新值，可以使用传统的 JavaScript 事件对象的属性，如 event.target.value，而不是使用 React 组件的状态（state）。</p>
</li>
</ul>
<p>总的来说，React 的事件机制提供了便捷的事件处理方式，封装了常用的浏览器事件，提供了跨浏览器兼容性和一些额外的功能。开发者可以通过声明式的方式来管理组件的交互行为和数据流动。</p>
<h1 id="React-事件绑定的方式"><a href="#React-事件绑定的方式" class="headerlink" title="React 事件绑定的方式"></a>React 事件绑定的方式</h1><ol>
<li><p><strong>在组件标签中直接绑定事件属性</strong></p>
<ul>
<li>例如：<code>&lt;button onClick=&#123;handleClick&#125;&gt;Click Me&lt;/button&gt;</code></li>
<li>将事件处理函数直接赋值给组件标签的事件属性，常用于简单的事件处理。</li>
</ul>
</li>
<li><p><strong>在组件类中使用箭头函数</strong></p>
<ul>
<li>例如：<code>handleClick = () =&gt; &#123; // 处理函数 &#125;</code></li>
<li>在组件类中定义事件处理函数时使用箭头函数，以绑定函数的作用域，并确保 this 指向当前组件实例。</li>
</ul>
</li>
<li><p><strong>使用 bind 方法绑定事件处理函数</strong></p>
<ul>
<li>例如：<code>&lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;Click Me&lt;/button&gt;</code></li>
<li>在组件类中使用 <code>bind</code> 方法绑定事件处理函数的 this 上下文，以确保函数内部的 this 指向当前组件实例。</li>
</ul>
</li>
</ol>
<h3 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h3><ul>
<li>第一种方式是最常用和首选的方式，简洁明了，适用于大多数的事件处理场景。</li>
<li>第二种方式通过箭头函数绑定事件处理函数，省去了在构造函数中手动绑定的步骤，但会在每次渲染时创建一个新的函数，可能会影响性能，适用于简单的事件处理和箭头函数的语法偏好。</li>
<li>第三种方式使用 bind 方法绑定事件处理函数，可以在构造函数中一次性绑定所有的事件处理函数，但比较繁琐，适用于需要高度优化的场景或需要手动指定事件处理函数的 this 上下文。</li>
</ul>
<h1 id="React-构建组件的方式"><a href="#React-构建组件的方式" class="headerlink" title="React 构建组件的方式"></a>React 构建组件的方式</h1><ol>
<li><p><strong>类组件</strong>：</p>
<ul>
<li>使用 ES6 class 关键字定义的组件，继承自 <code>React.Component</code>。</li>
<li>使用 <code>render</code> 方法返回组件的 UI，可以使用生命周期方法和状态(State)。</li>
<li>适用于复杂的组件，可以使用状态和生命周期方法，有较好的逻辑复用性。</li>
</ul>
</li>
<li><p><strong>函数式组件</strong>：</p>
<ul>
<li>使用纯 JavaScript 函数来定义的组件，接收 props 对象作为参数。</li>
<li>通过返回 JSX 来描述组件的 UI，没有自己的状态(State)和生命周期方法。</li>
<li>适用于简单的 UI 呈现组件或者仅依赖 props 渲染的组件，比较轻量且易于理解。</li>
</ul>
</li>
<li><p><strong>PureComponent</strong>：</p>
<ul>
<li>类似于类组件，继承自 <code>React.PureComponent</code>。</li>
<li>带有性能优化，会通过浅比较来比较 props 和 state，在 shouldComponentUpdate 方法中减少不必要的重新渲染。</li>
<li>适用于需要性能优化的组件，可以减少不必要的组件更新。</li>
</ul>
</li>
</ol>
<h3 id="区别-2"><a href="#区别-2" class="headerlink" title="区别"></a>区别</h3><ul>
<li>类组件适用于较为复杂的组件，可以管理自己的状态和生命周期方法，以及处理复杂的逻辑。函数式组件则更适合简单的 UI 呈现组件或者只依赖 props 渲染的组件，比较轻量且易于理解。</li>
<li>PureComponent 是一种对类组件的性能优化，通过浅比较来减少不必要的重新渲染，适用于需要优化性能的场景。</li>
</ul>
<h1 id="React-中引入-CSS-的方式"><a href="#React-中引入-CSS-的方式" class="headerlink" title="React 中引入 CSS 的方式"></a>React 中引入 CSS 的方式</h1><ol>
<li><p><strong>普通方式</strong>：</p>
<ul>
<li>直接在 React 组件的 JSX 中使用 <code>className</code> 属性，然后在对应的 CSS 文件中定义样式。</li>
<li>适用于简单的样式引入和使用，但缺少模块化和组件化的特性。</li>
</ul>
</li>
<li><p><strong>CSS Modules</strong>：</p>
<ul>
<li>使用 <code>*.module.css</code> 或 <code>*.module.scss</code> 等命名规范的 CSS 文件，使得样式表具有局部作用域。</li>
<li>在组件中引入样式时，可以通过 <code>import</code> 语句直接引入样式文件，并使用类名访问样式，避免全局污染。适用于组件化开发和样式隔离。</li>
</ul>
</li>
<li><p><strong>CSS-in-JS</strong>：</p>
<ul>
<li>使用 JavaScript 对象、模板字符串或函数来定义样式，然后将其引入到组件中。</li>
<li>在 React 中有多个流行的 CSS-in-JS 库，如 styled-components、Emotion 等，可以将组件的样式逻辑内联到组件定义中。</li>
<li>适用于将样式逻辑紧密绑定到组件逻辑中，提高组件的易读性和可维护性。</li>
</ul>
</li>
</ol>
<h3 id="区别-3"><a href="#区别-3" class="headerlink" title="区别"></a>区别</h3><ul>
<li>普通方式简单直接，适用于简单的样式引入和使用，但缺乏模块化和组件化的特性。</li>
<li>CSS Modules 提供了局部作用域的样式引入方式，使得组件样式具有封闭的作用域，适用于组件化开发和样式隔离。</li>
<li>CSS-in-JS 则将样式逻辑紧密绑定到组件逻辑中，提高了组件的易读性和可维护性，适用于将样式作为组件的一部分来管理。</li>
</ul>
<p>根据具体的项目需求和团队偏好，可以选择合适的 CSS 引入方式。常见的情况下，CSS Modules 和 CSS-in-JS 在项目中得到较多应用，能够较好地支持组件化和样式隔离的需求。</p>
<h1 id="React-生命周期的不同阶段"><a href="#React-生命周期的不同阶段" class="headerlink" title="React 生命周期的不同阶段"></a>React 生命周期的不同阶段</h1><ol>
<li><p><strong>挂载阶段(Mounting)</strong></p>
<ul>
<li><code>constructor</code>：组件实例被创建时调用，用于初始化状态和绑定事件处理函数。</li>
<li><code>static getDerivedStateFromProps</code>：在组件实例化和渲染过程中，每次接收到新的 props 时调用，用于更新状态。</li>
<li><code>render</code>：根据组件的状态和 props，返回要渲染的 JSX 元素。</li>
<li><code>componentDidMount</code>：组件首次渲染完成后调用，可以进行 DOM 操作或发起网络请求。</li>
</ul>
</li>
<li><p><strong>更新阶段(Updating)</strong></p>
<ul>
<li><code>static getDerivedStateFromProps</code>：在接收到新的 props 时调用，用于更新状态。</li>
<li><code>shouldComponentUpdate</code>：在接收到新的 props 或 state 时调用，决定是否重新渲染组件。</li>
<li><code>render</code>：根据组件的状态和 props，返回要渲染的 JSX 元素。</li>
<li><code>getSnapshotBeforeUpdate</code>：在渲染之前捕获 DOM 状态，可以进行一些 DOM 的操作。</li>
<li><code>componentDidUpdate</code>：组件更新完成后调用，可以进行 DOM 操作或发起网络请求。</li>
</ul>
</li>
<li><p><strong>卸载阶段(Unmounting)</strong></p>
<ul>
<li><code>componentWillUnmount</code>：组件将要被卸载前调用，可以进行一些清理操作，如取消订阅或清除定时器。</li>
</ul>
</li>
<li><p><strong>错误处理阶段(Error Handling)</strong></p>
<ul>
<li><code>static getDerivedStateFromError</code>：在子组件抛出错误后调用，在渲染过程中捕获错误，返回新的状态。</li>
<li><code>componentDidCatch</code>：在子组件抛出错误后调用，进行错误日志记录或展示友好的错误界面。</li>
</ul>
</li>
</ol>
<h3 id="额外的方法"><a href="#额外的方法" class="headerlink" title="额外的方法"></a>额外的方法</h3><p>此外，还有一些额外的生命周期方法，用于在特定情况下进行处理：</p>
<ul>
<li><code>static getDerivedStateFromProps</code>：在组件类中定义静态方法时使用。</li>
<li><code>getSnapshotBeforeUpdate</code> 和 <code>componentDidUpdate</code> 通常一起使用，用于在组件更新过程中获取和保存滚动位置等信息。</li>
<li><code>componentDidCatch</code> 用于捕获子组件的错误，并进行错误处理。</li>
</ul>
<p>注意：从 React 17 开始，一些生命周期方法已被标记为过时(deprecated)。建议使用新的生命周期方法替代它们，如 <code>getDerivedStateFromProps</code>、<code>getSnapshotBeforeUpdate</code> 和 <code>componentDidCatch</code>。</p>
<h1 id="React中组件之间如何通信？"><a href="#React中组件之间如何通信？" class="headerlink" title="React中组件之间如何通信？"></a>React中组件之间如何通信？</h1><ol>
<li><p><strong>Props 隐式传递</strong>：</p>
<ul>
<li>父组件可以通过 props 将数据传递给子组件，子组件可以通过 props 接收父组件传递的数据。这种单向数据流的方式适用于父子组件之间简单的通信。</li>
</ul>
</li>
<li><p><strong>回调函数</strong>：</p>
<ul>
<li>父组件可以通过 props 将回调函数传递给子组件，子组件可以调用该回调函数来通知父组件某些事件的发生。这种方式适用于子组件需要向父组件报告事件的情况。</li>
</ul>
</li>
<li><p><strong>Context 上下文</strong>：</p>
<ul>
<li>使用 React 的 Context 特性，可以在组件树中传递数据，避免通过手动层层传递 props 的方式。这种方式适用于跨层级的组件通信，但应谨慎使用以避免过度依赖上下文。</li>
</ul>
</li>
<li><p><strong>全局状态管理（如 Redux、MobX 等）</strong>：</p>
<ul>
<li>使用全局状态管理工具可以将共享状态提升到应用的整体级别，各个组件可以通过订阅状态更新来实现通信。这种方式适用于大型应用中多个组件之间频繁的通信需求。</li>
</ul>
</li>
<li><p><strong>事件池</strong>：</p>
<ul>
<li>在 React 中，可以通过创建自定义事件，让父组件监听这些自定义事件，并在子组件中触发这些事件来实现组件之间的通信。</li>
</ul>
</li>
<li><p><strong>第三方库（如 EventBus）</strong>：</p>
<ul>
<li>可以使用第三方的事件总线库（EventBus）来实现组件之间的解耦通信，这种方式适用于组件关系复杂，需要进行解耦的情况。</li>
</ul>
</li>
</ol>
<p>以上方式适用于不同场景下的组件通信需求，具体可以根据项目的规模和复杂度来选择合适的通信方式。</p>
<h1 id="说说对高阶组件的理解？应用场景？"><a href="#说说对高阶组件的理解？应用场景？" class="headerlink" title="说说对高阶组件的理解？应用场景？"></a>说说对高阶组件的理解？应用场景？</h1><p><strong>高阶组件（Higher-Order Component，HOC）</strong></p>
<p>高阶组件（HOC）是一种在 React 中用于复用组件逻辑的高级技术。它本质上是一个函数，接受一个组件作为参数，并返回一个新的经过增强的组件。HOC 不会修改原始组件，而是通过包裹组件来增强它的功能。</p>
<p>HOC 可以用于以下场景：</p>
<ol>
<li><p><strong>代码复用</strong>：HOC 可以将常用的逻辑封装在一个高阶组件中，然后在多个组件中复用该逻辑，提高代码复用性。</p>
</li>
<li><p><strong>状态管理</strong>：HOC 可以用于管理和共享状态，例如使用 Redux、MobX 或者其他状态管理库。</p>
</li>
<li><p><strong>权限控制</strong>：HOC 可以用于进行权限控制，根据用户的权限限制组件的渲染或操作。</p>
</li>
<li><p><strong>性能优化</strong>：HOC 可以用于优化组件的性能，例如通过对组件进行懒加载、缓存结果或者进行数据预处理等。</p>
</li>
</ol>
<h1 id="在react中组件间过渡动画如何实现？"><a href="#在react中组件间过渡动画如何实现？" class="headerlink" title="在react中组件间过渡动画如何实现？"></a>在react中组件间过渡动画如何实现？</h1><ol>
<li><p><strong>CSS 过渡动画</strong>：利用 CSS 过渡动画来实现组件间的过渡效果。可以通过添加相应的 CSS 类来触发过渡效果，在组件即将进入或离开时添加或删除对应的类。</p>
</li>
<li><p><strong>React Transition Group 库</strong>：可以使用 React Transition Group 库来实现更复杂的过渡效果，例如淡入淡出、滑动等效果。这个库提供了一些组件，如 <code>CSSTransition</code> 和 <code>TransitionGroup</code>，可以方便地实现组件间的过渡效果。</p>
</li>
<li><p><strong>第三方动画库</strong>：除了 React Transition Group，还可以使用其他第三方动画库，如 React Spring、React Motion 等，来实现更加复杂和流畅的过渡动画效果。</p>
</li>
<li><p><strong>Hooks 和状态管理</strong>：结合 React Hooks 和状态管理来实现自定义的过渡动画效果。通过定义状态控制组件的动画状态，再利用 Hooks 中的 useEffect 等方法来监听状态变化并触发相应的动画效果。</p>
</li>
</ol>
<p>总的来说，要实现组件间的过渡动画效果，可以选择适合场景的方法，如使用 CSS 过渡动画简单地实现一些效果，或者使用专门的库来实现更复杂的动画效果。选择合适的方法可以让过渡动画实现起来更加高效和易维护。</p>
<h1 id="说说你在React项目是如何捕获错误的？"><a href="#说说你在React项目是如何捕获错误的？" class="headerlink" title="说说你在React项目是如何捕获错误的？"></a>说说你在React项目是如何捕获错误的？</h1><ol>
<li><p><strong>Error Boundaries（错误边界）</strong>：可以使用 React 的 Error Boundary 来捕获组件树中任何位置的 JavaScript 错误，并渲染一个备用 UI，以避免整个应用崩溃。通过定义一个错误边界组件，在组件的 <code>componentDidCatch(error, info)</code> 方法中捕获错误并处理。</p>
</li>
<li><p><strong>try-catch</strong>：在类组件的生命周期方法（如 <code>render</code>、<code>componentDidMount</code> 等）或函数组件的主体部分中，可以使用 JavaScript 的 <code>try-catch</code> 语句来捕获特定代码段的错误。</p>
</li>
<li><p><strong>全局错误处理</strong>：可以通过监听全局的 <code>unhandledrejection</code> 和 <code>error</code> 事件来捕获未被处理的 Promise 错误和一般错误，并在事件处理函数中进行相应的错误处理和记录。</p>
</li>
<li><p><strong>日志记录</strong>：在捕获到错误后，可以通过日志记录工具（如 Sentry、LogRocket 等）将错误信息发送给后端或记录到日志系统中，以帮助开发者定位和解决问题。</p>
</li>
<li><p><strong>测试</strong>：编写单元测试和集成测试用例，以尽早发现潜在的错误，并确保代码的稳定性和可靠性。</p>
</li>
</ol>
<h1 id="说说对React-refs-的理解？应用场景？"><a href="#说说对React-refs-的理解？应用场景？" class="headerlink" title="说说对React refs 的理解？应用场景？"></a>说说对React refs 的理解？应用场景？</h1><p><strong>React Refs（引用）</strong></p>
<p>在 React 中，ref 是用来访问 DOM 元素或者 class 组件实例的方法。ref 提供了一种在 React 组件中直接访问 DOM 元素或者其他组件实例的方式，可以用来操作 DOM、获取组件实例或者进行其他需要直接访问底层元素的操作。</p>
<p><strong>应用场景</strong>：</p>
<ol>
<li><p><strong>操作 DOM 元素</strong>：通过 ref 可以直接操作 DOM 元素，例如获取输入框的值、设置元素样式、滚动到特定位置等。</p>
</li>
<li><p><strong>表单控件聚焦</strong>：可以使用 ref 来在加载组件时使某个表单元素自动聚焦，改善用户体验。</p>
</li>
<li><p><strong>动画控制</strong>：通过 ref 可以触发动画效果，如在特定情况下执行动画、实现动态效果等。</p>
</li>
<li><p><strong>第三方库集成</strong>：有些第三方库可能需要直接访问 DOM 元素或者组件实例，这时可以利用 ref 来提供对这些库的交互接口。</p>
</li>
<li><p><strong>访问子组件实例</strong>：在某些情况下，需要直接访问子组件的实例或方法，这时可以通过 ref 来访问子组件并调用其方法。</p>
</li>
</ol>
<p>使用 ref 需要注意避免滥用，因为过多使用 ref 会使组件之间的耦合性增加，降低组件的可复用性和可维护性。因此，在使用 ref 的时候需要谨慎考虑其真正需求，并尽量避免直接操作 DOM 元素，而是优先考虑通过 props 和状态管理来实现组件之间的通信。</p>
<h1 id="说说React-中的-setState执行机制"><a href="#说说React-中的-setState执行机制" class="headerlink" title="说说React 中的 setState执行机制"></a>说说React 中的 setState执行机制</h1><p>在 React 中，setState 是用来更新组件状态的方法。当调用 setState 时，会触发 React 的更新机制，实现组件的重新渲染。setState 的执行机制可以总结如下：</p>
<ol>
<li><p><strong>异步更新</strong>：React 中的 setState 是异步的，多次调用 setState 会被合并成一次更新操作。这样可以提高性能，避免不必要的重复渲染。如果需要在 setState 被处理后执行某些操作，可以在 setState 的第二个参数中传入一个回调函数。</p>
</li>
<li><p><strong>批量更新</strong>：React 在事件处理函数和生命周期方法中调用 setState 时会将更新操作放入批量更新队列中，等到事件处理函数执行完毕或生命周期方法执行完毕后再统一进行更新，避免多次重复渲染。</p>
</li>
<li><p><strong>合并更新</strong>：当调用 setState 传入一个对象时，React 会将这个对象与当前状态合并，并更新组件的状态。这意味着只需要传入要更新的状态的部分数据，而不需要提供完整的状态对象。React 会智能地合并这些更新，确保状态得到正确更新。</p>
</li>
<li><p><strong>函数式更新</strong>：除了传入一个对象外，还可以传入一个函数作为参数，接收前一个状态作为参数，返回新的状态对象。这种方式适合依赖于前一个状态的更新操作。</p>
</li>
<li><p><strong>setState 的同步更新</strong>：在某些情况下，如果需要立即获取更新后的状态，可以使用函数式的 setState，并在其回调函数中执行相关操作，确保在状态更新后立即生效。也可用setTimeout</p>
</li>
</ol>
<p>总的来说，正确使用 setState 可以确保组件状态的正确更新及性能优化。理解 setState 的执行机制可以帮助开发者更好地把握状态管理和组件更新的时机，提高 React 应用的性能和可维护性。</p>
<h1 id="说说React-render-方法的原理？在什么时候会被触发？"><a href="#说说React-render-方法的原理？在什么时候会被触发？" class="headerlink" title="说说React render 方法的原理？在什么时候会被触发？"></a>说说React render 方法的原理？在什么时候会被触发？</h1><p>在 React 中，<code>render</code> 方法是 class 组件中必需的方法，用于定义组件的 UI 展示逻辑。<code>render</code> 方法的原理是将组件的虚拟 DOM 结构渲染到真实的 DOM 中，实现页面的展示。</p>
<p><code>render</code> 方法会在以下情况下被触发：</p>
<ol>
<li><p><strong>组件初始化</strong>：当组件被实例化并挂载到 DOM 树上时，React 会调用组件的 <code>render</code> 方法来生成初始的虚拟 DOM 结构，并将其渲染到页面上。</p>
</li>
<li><p><strong>props 或 state 改变</strong>：当组件的 props 或 state 发生变化时，React 会重新调用组件的 <code>render</code> 方法来重新生成虚拟 DOM 结构，并更新页面上的内容。</p>
</li>
<li><p><strong>父组件重新渲染</strong>：如果组件的父组件重新渲染，那么子组件的 <code>render</code> 方法也会被调用，以保持 DOM 树的一致性。</p>
</li>
<li><p><strong>forceUpdate 方法</strong>：调用组件的 <code>forceUpdate</code> 方法也会触发 <code>render</code> 方法的执行，强制组件重新渲染。</p>
</li>
</ol>
<p>在调用 <code>render</code> 方法后，React 会比较新生成的虚拟 DOM 和之前的虚拟 DOM，找出差异并将差异部分更新到真实的 DOM 中，从而实现页面内容的更新。值得注意的是，<code>render</code> 方法本身不应该包含任何副作用或异步操作，它仅用于定义组件的 UI 结构。</p>
<p>总之，<code>render</code> 方法是 React 实现组件渲染的核心，通过对其调用和控制，React 能够高效地管理组件的渲染过程，实现页面内容的动态更新和交互。</p>
<h1 id="说说Real-DOM和Virtual-DOM的区别？优缺点？"><a href="#说说Real-DOM和Virtual-DOM的区别？优缺点？" class="headerlink" title="说说Real DOM和Virtual DOM的区别？优缺点？"></a>说说Real DOM和Virtual DOM的区别？优缺点？</h1><p><strong>Real DOM 和 Virtual DOM 的区别</strong></p>
<ol>
<li><p><strong>Real DOM（真实 DOM）</strong>：</p>
<ul>
<li>Real DOM 是浏览器中实际存在的 Document Object Model（文档对象模型），它是由浏览器根据 HTML 文档解析而成的树状结构，用于表示页面的结构和内容。</li>
<li>操作 Real DOM 通常会触发页面的重新渲染和重排，这样的操作开销较大，会影响页面性能。</li>
<li>Real DOM 的更新是同步进行的，即使只修改了一个小部分，也会重新渲染整个页面。</li>
</ul>
</li>
<li><p><strong>Virtual DOM（虚拟 DOM）</strong>：</p>
<ul>
<li>Virtual DOM 是一个轻量级的 JS 对象，是对 Real DOM 的映射或抽象。React 和其他一些前端框架会在内存中维护一个 Virtual DOM 树，用于表示页面结构。</li>
<li>通过比对 Virtual DOM 的变化，React 可以最小化真实 DOM 的操作，提高页面渲染性能。</li>
<li>当组件的状态发生变化时，React 会重新构建 Virtual DOM，并通过 diff 算法找出 Virtual DOM 的变化部分，再将这部分更新到真实 DOM 中。</li>
</ul>
</li>
</ol>
<p><strong>优缺点对比</strong>：</p>
<ul>
<li><p><strong>Real DOM 优点</strong>：</p>
<ul>
<li>Real DOM 直接操作真实的页面元素，能够实时更新页面内容。</li>
<li>针对少量数据或交互较少的页面，Real DOM 的操作可能更简单高效。</li>
</ul>
</li>
<li><p><strong>Real DOM 缺点</strong>：</p>
<ul>
<li>操作 Real DOM 开销较大，可能导致页面性能下降，尤其是在复杂页面或数据量大时。</li>
<li>实时更新 Real DOM 可能会造成页面闪烁和卡顿。</li>
</ul>
</li>
<li><p><strong>Virtual DOM 优点</strong>：</p>
<ul>
<li>Virtual DOM 通过批量更新和 diff 算法最小化真实 DOM 操作，提高页面性能。</li>
<li>跨平台和跨平台兼容，便于实现组件的复用和组合。</li>
</ul>
</li>
<li><p><strong>Virtual DOM 缺点</strong>：</p>
<ul>
<li>需要额外的内存空间维护 Virtual DOM 结构，有一定的内存开销。</li>
<li>对于简单页面和少量数据，引入 Virtual DOM 可能会带来一定的性能损耗。</li>
</ul>
</li>
</ul>
<p>综上所述，Virtual DOM 通过优化真实 DOM 操作来提高页面性能和减少不必要的重绘；而 Real DOM 的实时更新能够直接呈现页面变化，但可能导致性能问题。根据具体场景和需求，开发者可以选择合适的方式来操作 DOM，以达到更好的性能和用户体验。</p>
<h1 id="说说React-Jsx-转换成真实-DOM过程？"><a href="#说说React-Jsx-转换成真实-DOM过程？" class="headerlink" title="说说React Jsx 转换成真实 DOM过程？"></a>说说React Jsx 转换成真实 DOM过程？</h1><p>在 React 中，JSX 是一种语法糖，用于描述组件的结构和内容。当编写 React 组件时，可以使用 JSX 来编写组件的 UI 结构，而在编译过程中，JSX 会被转换成真实的 JavaScript 对象表示的虚拟 DOM 结构，最终再通过 React 的协调算法，将虚拟 DOM 更新到真实的 DOM 中。下面是 React JSX 转换成真实 DOM 的过程：</p>
<ol>
<li><p><strong>JSX 编写组件</strong>：开发者使用 JSX 编写 React 组件，JSX 会被 Babel 或其他工具转换为 React.createElement() 或类似的方法调用。</p>
</li>
<li><p><strong>虚拟 DOM 树构建</strong>：在组件渲染过程中，React 创建一个虚拟 DOM 树，通过 React.createElement() 方法将 JSX 转换为虚拟 DOM 对象。每个虚拟 DOM 对象都对应着真实 DOM 中的一个节点，包括标签名、属性、子节点等信息。</p>
</li>
<li><p><strong>Diff 算法比对</strong>：当组件状态发生变化时，React 重新构建新的虚拟 DOM 树，并通过 Diff 算法比对新旧虚拟 DOM 树的差异，找出需要更新的部分。</p>
</li>
<li><p><strong>更新真实 DOM</strong>：一旦确定了需要更新的部分，React 会通过更新算法将这些变化更新到真实的 DOM 中，从而反映在页面上。这个过程也被称为协调算法（Reconciliation Algorithm）。</p>
</li>
<li><p><strong>DOM 更新完成</strong>：更新完成后，页面会展示最新的内容，并且只更新了需要更新的部分，而不是整个页面。</p>
</li>
</ol>
<p>总的来说，当编写 React 组件时使用 JSX，最终会被转换成虚拟 DOM 结构，React 通过比对虚拟 DOM 的变化来最小化对真实 DOM 的操作，从而提高性能和效率。这个过程确保了页面只更新需要更新的部分，减少不必要的重绘和重排，提升了页面的渲染效率。</p>
<h1 id="hoc代码实现方式之props"><a href="#hoc代码实现方式之props" class="headerlink" title="hoc代码实现方式之props"></a>hoc代码实现方式之props</h1><p>HOC 的实现方式之一是通过 props 的方式传递逻辑给被包裹的组件。下面是一个简单的示例代码，演示了如何通过 props 实现一个简单的 HOC：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高阶组件函数，接受一个组件作为参数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">withHOC</span> = (<span class="params">WrappedComponent</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 返回一个新的组件</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">HOCComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="comment">// 在这个新的组件中添加额外的逻辑</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是高阶组件添加的内容<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;/* 通过 props 将原组件传递下去 */&#125;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被包裹的普通组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyComponent</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是我的组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;props.text&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用高阶组件包裹普通组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyHOCComponent</span> = <span class="title function_">withHOC</span>(<span class="title class_">MyComponent</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染被包裹后的组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">MyHOCComponent</span> <span class="attr">text</span>=<span class="string">&quot;这是传递给普通组件的 props&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>withHOC</code> 函数接受一个普通的 React 组件作为参数，然后返回一个新的组件 <code>HOCComponent</code>，在这个新的组件中添加了额外的逻辑。通过 props 将被包裹的组件 <code>MyComponent</code> 所需的 props 传递给它，从而实现了对原组件的包裹和逻辑增强。</p>
<p>使用高阶组件可以帮助我们在不修改原组件的情况下，通过包裹的方式给组件添加额外的功能和逻辑。通过 props 传递信息是实现高阶组件的一种常见方式，同时也可以结合其他方法实现更加复杂的逻辑增强。</p>
<h1 id="hoc高阶组件使用技巧"><a href="#hoc高阶组件使用技巧" class="headerlink" title="hoc高阶组件使用技巧"></a>hoc高阶组件使用技巧</h1><p>使用高阶组件（Higher Order Component，HOC）是在 React 中实现组件复用和逻辑抽象的常见技巧之一。以下是一些使用高阶组件的技巧和最佳实践：</p>
<ol>
<li><p><strong>逻辑复用</strong>：使用高阶组件可以将共享的逻辑抽象出来，提高代码的可复用性。例如，可以创建一个处理认证逻辑的高阶组件，用于验证用户是否已登录。</p>
</li>
<li><p><strong>渲染劫持</strong>：高阶组件可以在渲染过程中对组件的渲染进行劫持，从而实现某些功能，比如条件渲染、渲染前后的操作等。</p>
</li>
<li><p><strong>属性代理</strong>：通过高阶组件可以将 props 传递给包裹的组件，实现属性的代理和转换。这样可以在原组件中访问高阶组件传递的 props，实现更灵活的传递和处理。</p>
</li>
<li><p><strong>状态管理</strong>：高阶组件可以处理状态逻辑，比如提供状态管理、异步数据获取等功能，从而让被包裹的组件专注于 UI 渲染而将逻辑分离出去。</p>
</li>
<li><p><strong>性能优化</strong>：高阶组件可以通过控制组件的渲染条件、触发渲染的时机等方式进行性能优化，避免不必要的渲染。</p>
</li>
<li><p><strong>链式调用</strong>：多个高阶组件可以串联使用，形成一个高阶组件的链式调用，每个高阶组件负责一个独立的功能，提高代码的可维护性和复用性。</p>
</li>
<li><p><strong>参数化高阶组件</strong>：高阶组件可以接收参数，从而使高阶组件的功能更加灵活和通用化。这样可以根据不同的参数配置高阶组件的行为。</p>
</li>
<li><p><strong>组件包装</strong>：高阶组件可以在渲染过程中对组件进行包装，比如添加额外的样式、事件处理、逻辑等，实现组件的定制化和增强。</p>
</li>
</ol>
<p>通过合理使用高阶组件，可以将代码进行分解、抽象和复用，提高 React 应用的可维护性和扩展性。但需要注意避免过度使用高阶组件，以避免造成代码复杂度的增加和组件关系的混乱。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://zej574099903.github.io">皮蛋瘦肉周</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://zej574099903.github.io/2024/02/23/react/">https://zej574099903.github.io/2024/02/23/react/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zej574099903.github.io" target="_blank">Code Chronicles</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/react.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/02/26/vue/" title="vue"><img class="cover" src="/img/loading.gif" data-original="/img/vue.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">vue</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">皮蛋瘦肉周</div><div class="author-info__description">Welcome to Jhon's Home</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zej574099903/zej574099903.github.io"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://githubfast.com/lyr233" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/YR_112233" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=728831102&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:728831102@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9React%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E7%89%B9%E6%80%A7"><span class="toc-number">1.</span> <span class="toc-text">对React的理解和特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3"><span class="toc-number">1.1.</span> <span class="toc-text">理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">1.3.</span> <span class="toc-text">优势</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-State%EF%BC%88%E7%8A%B6%E6%80%81%EF%BC%89%E5%92%8C-Props%EF%BC%88%E5%B1%9E%E6%80%A7%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">区别 State（状态）和 Props（属性）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-super-%E5%92%8C-super-props"><span class="toc-number">3.</span> <span class="toc-text">区别 super() 和 super(props)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">类组件和函数组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">4.0.1.</span> <span class="toc-text">区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">5.</span> <span class="toc-text">受控组件和非受控组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.0.1.</span> <span class="toc-text">应用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React-%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">6.</span> <span class="toc-text">React 的事件机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">6.0.1.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">React 事件绑定的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-1"><span class="toc-number">7.0.1.</span> <span class="toc-text">区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React-%E6%9E%84%E5%BB%BA%E7%BB%84%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">8.</span> <span class="toc-text">React 构建组件的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-2"><span class="toc-number">8.0.1.</span> <span class="toc-text">区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React-%E4%B8%AD%E5%BC%95%E5%85%A5-CSS-%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">9.</span> <span class="toc-text">React 中引入 CSS 的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-3"><span class="toc-number">9.0.1.</span> <span class="toc-text">区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E4%B8%8D%E5%90%8C%E9%98%B6%E6%AE%B5"><span class="toc-number">10.</span> <span class="toc-text">React 生命周期的不同阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">10.0.1.</span> <span class="toc-text">额外的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React%E4%B8%AD%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">React中组件之间如何通信？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">说说对高阶组件的理解？应用场景？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8react%E4%B8%AD%E7%BB%84%E4%BB%B6%E9%97%B4%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">在react中组件间过渡动画如何实现？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%9C%A8React%E9%A1%B9%E7%9B%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8D%95%E8%8E%B7%E9%94%99%E8%AF%AF%E7%9A%84%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">说说你在React项目是如何捕获错误的？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9React-refs-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">说说对React refs 的理解？应用场景？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4React-%E4%B8%AD%E7%9A%84-setState%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">16.</span> <span class="toc-text">说说React 中的 setState执行机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4React-render-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%A2%AB%E8%A7%A6%E5%8F%91%EF%BC%9F"><span class="toc-number">17.</span> <span class="toc-text">说说React render 方法的原理？在什么时候会被触发？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Real-DOM%E5%92%8CVirtual-DOM%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">18.</span> <span class="toc-text">说说Real DOM和Virtual DOM的区别？优缺点？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4React-Jsx-%E8%BD%AC%E6%8D%A2%E6%88%90%E7%9C%9F%E5%AE%9E-DOM%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">说说React Jsx 转换成真实 DOM过程？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#hoc%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%B9%8Bprops"><span class="toc-number">20.</span> <span class="toc-text">hoc代码实现方式之props</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#hoc%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7"><span class="toc-number">21.</span> <span class="toc-text">hoc高阶组件使用技巧</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/02/23/react/" title="react"><img src="/img/loading.gif" data-original="/img/react.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="react"/></a><div class="content"><a class="title" href="/2024/02/23/react/" title="react">react</a><time datetime="2024-02-23T07:15:55.000Z" title="发表于 2024-02-23 15:15:55">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/26/vue/" title="vue"><img src="/img/loading.gif" data-original="/img/vue.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vue"/></a><div class="content"><a class="title" href="/2023/02/26/vue/" title="vue">vue</a><time datetime="2023-02-26T09:14:03.000Z" title="发表于 2023-02-26 17:14:03">2023-02-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/react.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 皮蛋瘦肉周</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>