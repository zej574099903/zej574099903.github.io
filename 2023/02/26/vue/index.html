<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>vue | Code Chronicles</title><meta name="author" content="皮蛋瘦肉周"><meta name="copyright" content="皮蛋瘦肉周"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="描述下对vue生命周期的理解Vue 的生命周期钩子函数指的是在 Vue 实例创建、运行过程中，会自动调用的一些特定命名的函数，开发者可以在这些函数中执行自定义的代码逻辑。Vue 的生命周期包括了创建、挂载、更新、销毁等阶段，下面是对 Vue 生命周期钩子函数的简要描述：  beforeCreate：在实例初始化之后，数据观测和事件配置之前被调用，此时实例的 data 和 methods 等选项尚未">
<meta property="og:type" content="article">
<meta property="og:title" content="vue">
<meta property="og:url" content="https://zej574099903.github.io/2023/02/26/vue/index.html">
<meta property="og:site_name" content="Code Chronicles">
<meta property="og:description" content="描述下对vue生命周期的理解Vue 的生命周期钩子函数指的是在 Vue 实例创建、运行过程中，会自动调用的一些特定命名的函数，开发者可以在这些函数中执行自定义的代码逻辑。Vue 的生命周期包括了创建、挂载、更新、销毁等阶段，下面是对 Vue 生命周期钩子函数的简要描述：  beforeCreate：在实例初始化之后，数据观测和事件配置之前被调用，此时实例的 data 和 methods 等选项尚未">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zej574099903.github.io/img/vue.jpg">
<meta property="article:published_time" content="2023-02-26T09:14:03.000Z">
<meta property="article:modified_time" content="2024-02-28T05:51:43.782Z">
<meta property="article:author" content="皮蛋瘦肉周">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zej574099903.github.io/img/vue.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zej574099903.github.io/2023/02/26/vue/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'vue',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-28 13:51:43'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/vue_top.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Code Chronicles"><span class="site-name">Code Chronicles</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">vue</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-26T09:14:03.000Z" title="发表于 2023-02-26 17:14:03">2023-02-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-28T05:51:43.782Z" title="更新于 2024-02-28 13:51:43">2024-02-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="vue"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="描述下对vue生命周期的理解"><a href="#描述下对vue生命周期的理解" class="headerlink" title="描述下对vue生命周期的理解"></a>描述下对vue生命周期的理解</h1><p>Vue 的生命周期钩子函数指的是在 Vue 实例创建、运行过程中，会自动调用的一些特定命名的函数，开发者可以在这些函数中执行自定义的代码逻辑。Vue 的生命周期包括了创建、挂载、更新、销毁等阶段，下面是对 Vue 生命周期钩子函数的简要描述：</p>
<ol>
<li><p><strong>beforeCreate</strong>：在实例初始化之后，数据观测和事件配置之前被调用，此时实例的 data 和 methods 等选项尚未初始化。</p>
</li>
<li><p><strong>created</strong>：在实例创建完成后被立即调用，此时实例已经完成数据观测、属性和方法的运算，但挂载阶段尚未开始，无法访问 DOM 元素。</p>
</li>
<li><p><strong>beforeMount</strong>：在挂载开始之前被调用，相关的 render 函数首次被调用。</p>
</li>
<li><p><strong>mounted</strong>：在实例挂载结束后调用，此时实例已经完成挂载，可以访问到模板中的 DOM 元素。通常在这里进行 DOM 操作或者调用第三方库。</p>
</li>
<li><p><strong>beforeUpdate</strong>：在数据更新导致重新渲染之前被调用，可以在这里对更新之前的数据和状态进行处理。</p>
</li>
<li><p><strong>updated</strong>：在数据更新导致 DOM 重新渲染和 patch 之后被调用，此时组件已经更新，可以执行依赖 DOM 的操作。</p>
</li>
<li><p><strong>beforeDestroy</strong>：在实例销毁之前调用，此时实例仍然完全可用，通常用来做一些清理工作，比如清除定时器、解绑事件等。</p>
</li>
<li><p><strong>destroyed</strong>：在实例销毁之后调用，此时实例所有的绑定都被解除，可以进行一些清理操作，如取消订阅、销毁实例等。</p>
</li>
</ol>
<p>除了以上主要的生命周期钩子函数外，Vue 还提供了一些其他的钩子函数，如 activated、deactivated 等，用于处理 keep-alive 中缓存组件的生命周期。</p>
<p>通过合理地利用 Vue 的生命周期钩子函数，开发者可以在不同的阶段执行特定的操作，例如数据预处理、DOM 操作、订阅事件、资源释放等，从而实现更加灵活和可控的应用程序逻辑。</p>
<h1 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h1><p>双向数据绑定是指当数据模型发生变化时，视图也会相应地更新，同时当用户在视图中输入数据时，数据模型也会相应地更新的机制。在前端框架中，双向数据绑定可以提高应用的开发效率和用户体验，让数据与视图之间的同步更加简单和自然。</p>
<p>在 Vue 和 Angular 这样的前端框架中，双向数据绑定的实现方式通常是通过数据绑定和事件监听来实现的。下面是一个简单的说明双向数据绑定的实现过程：</p>
<ol>
<li><p><strong>数据绑定</strong>：在模板中使用特定的语法将数据模型和视图元素进行绑定，例如在 Vue 中使用 <code>v-model</code> 指令，Angular 中使用 <code>[(ngModel)]</code> 指令。这样，数据在视图中的显示就和数据模型建立了关联。</p>
</li>
<li><p><strong>视图更新</strong>：当数据模型发生改变时（例如通过用户交互或其他原因），触发数据绑定机制，框架会自动更新相关的视图元素，使其显示最新的数据值。</p>
</li>
<li><p><strong>用户输入</strong>：当用户在视图元素中输入数据时（比如输入框中输入文本），框架会监听用户输入事件（比如输入事件或点击事件），然后更新数据模型中对应的数据属性。</p>
</li>
<li><p><strong>数据变化响应</strong>：一旦数据模型发生变化，框架会通过双向数据绑定机制自动更新与之相关联的视图元素，确保用户看到最新的数据反映出来。</p>
</li>
</ol>
<p>总的来说，双向数据绑定使得开发者无需手动管理数据和视图之间的同步，提高了开发效率和代码可维护性。然而，需要谨慎使用双向数据绑定，避免过多的绑定导致性能问题或难以追踪的数据流。在 Vue 和 React 等现代前端框架中，也提供了单向数据流和状态管理的概念，以解决复杂应用场景下双向数据绑定可能出现的问题。</p>
<h1 id="双向收集是如何实现的？"><a href="#双向收集是如何实现的？" class="headerlink" title="双向收集是如何实现的？"></a>双向收集是如何实现的？</h1><p>双向数据绑定中的双向收集指的是将视图中的数据变化实时地同步到数据模型中的过程。在 Vue.js 中，双向收集是通过指令 <code>v-model</code> 来实现的。下面是一个简单的说明双向收集的实现原理：</p>
<ol>
<li><p><strong>指令绑定</strong>：在 Vue 模板中，使用 <code>v-model</code> 指令绑定一个表单元素（如输入框、选择框等），例如：<code>&lt;input v-model=&quot;message&quot;&gt;</code>，这样就将这个表单元素和数据模型中的 <code>message</code> 属性建立了双向绑定关系。</p>
</li>
<li><p><strong>输入触发</strong>：当用户在这个表单元素中输入数据时，会触发对应的输入事件（比如 <code>input</code> 事件），Vue 会监听到这个事件。</p>
</li>
<li><p><strong>双向收集</strong>：Vue 在监听到用户输入事件后，会实时地更新数据模型中 <code>message</code> 属性的值，以与输入框中的内容保持同步。这个过程就是双向收集的过程，即将视图中的数据变化收集回数据模型。</p>
</li>
<li><p><strong>数据更新</strong>：一旦数据模型中的 <code>message</code> 属性发生变化（比如通过另一个方法或其他操作改变了这个属性的值），由于双向绑定的机制，相关的视图元素也会实时更新，保持数据模型和视图之间的同步。</p>
</li>
</ol>
<p>通过双向数据绑定和双向收集机制，Vue 实现了数据模型与视图之间的实时双向同步，并且让开发者无需手动处理数据变化时更新视图或用户输入时更新数据模型的逻辑。这一机制简化了开发复杂应用的过程，提高了开发效率和用户体验。在实际应用中，开发者可以充分利用 Vue 提供的双向数据绑定机制来简化开发过程，使得组件之间的数据交互更加便捷。</p>
<h1 id="vue组件通信方式"><a href="#vue组件通信方式" class="headerlink" title="vue组件通信方式"></a>vue组件通信方式</h1><p>Vue 组件通信是指不同组件之间进行数据传递、消息传递或触发特定行为的过程。Vue 提供了多种方式来实现组件之间的通信，主要包括以下几种方式：</p>
<ol>
<li><p><strong>props &#x2F; $emit</strong>：父组件通过 props 向子组件传递数据，子组件通过 $emit 方法触发事件通知父组件。这是一种单向数据流的通信方式，适用于父子组件之间的通信。</p>
</li>
<li><p><strong>$emit &#x2F; $on</strong>：通过 Vue 实例的事件系统，可以在任意组件中使用 $emit 触发自定义事件，并在需要的地方通过 $on 监听事件。可以用于非父子组件之间的通信。</p>
</li>
<li><p><strong>$refs</strong>：通过 ref 特性为子组件或 DOM 元素赋予引用信息，在父组件中可以通过 $refs 访问子组件或 DOM 元素，进行直接的数据传递或操作。</p>
</li>
<li><p><strong>Vuex</strong>：Vue 提供的状态管理模式，适用于多个组件共享状态的场景，通过集中式存储管理应用的所有组件的状态，实现组件之间的通信。</p>
</li>
<li><p><strong>事件总线</strong>：通过新建一个空的 Vue 实例作为事件总线，可以在任意组件中触发事件和监听事件，实现组件间的解耦合通信。</p>
</li>
<li><p><strong>Provide &#x2F; Inject</strong>：父组件通过 provide 提供数据，子组件通过 inject 注入数据。这种方式可以在层级较深的组件树中传递数据，不需要通过 props 一层层传递。</p>
</li>
<li><p><strong>$attrs &#x2F; $listeners</strong>：在高阶组件或者组件库中，通过 $attrs 和 $listeners 可以将父组件传递的属性和事件传递给子组件。</p>
</li>
</ol>
<p>以上是常见的 Vue 组件通信方式，开发者可以根据具体场景和需求选择合适的通信方式来实现组件之间的数据传递和交互。不同的通信方式适用于不同的场景，灵活运用可以使组件间的通信更加高效和方便。</p>
<h1 id="vue-data的属性为什么是一个函数而不是对象？"><a href="#vue-data的属性为什么是一个函数而不是对象？" class="headerlink" title="vue data的属性为什么是一个函数而不是对象？"></a>vue data的属性为什么是一个函数而不是对象？</h1><p>在 Vue.js 中，一个组件的 <code>data</code> 属性通常被定义为一个函数，而不是一个对象，这是为了确保每个组件实例都有其自己的数据副本，避免数据共享导致的意外行为。下面是一些原因：</p>
<ol>
<li><p><strong>数据独立性</strong>：当 <code>data</code> 返回一个函数时，每个组件实例都会调用该函数来生成独立的数据对象，确保了每个组件实例的数据是相互独立的，避免了数据共享导致的错乱情况。</p>
</li>
<li><p><strong>避免引用共享</strong>：如果 <code>data</code> 直接是一个对象，那么在多个组件实例中引用相同的对象时，它们实际上会共享同一个对象，一个组件的数据改变可能会影响到其他组件的数据，这可能导致不可预测的结果。</p>
</li>
<li><p><strong>数据响应性</strong>：Vue 会将 <code>data</code> 函数返回的对象进行响应式处理，当数据发生改变时，相关的视图会自动更新。通过返回函数来生成数据对象，Vue 能够更好地管理数据的响应性。</p>
</li>
</ol>
<p>举例来说，如果 <code>data</code> 直接是一个对象，那么多个组件实例可能引用相同的对象，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>data</code> 直接是一个对象，在多个组件中引用的话，它们实际上引用了同一个数据对象，这样会导致数据共享的问题。而将 <code>data</code> 定义为返回函数的方式，可以确保每个组件实例都有独立的数据对象，避免了数据共享的问题。</p>
<p>因此，为了保证组件数据的独立性和避免引用共享可能带来的问题，Vue 推荐将 <code>data</code> 属性定义为一个返回数据对象的函数。</p>
<h1 id="v-show-v-if的原理分析"><a href="#v-show-v-if的原理分析" class="headerlink" title="v-show v-if的原理分析"></a>v-show v-if的原理分析</h1><p><code>v-show</code> 和 <code>v-if</code> 是 Vue.js 中常用的用于条件渲染的指令，它们的原理略有不同，下面我来为你分别进行解释和比较：</p>
<ol>
<li><p><strong>v-show</strong>：</p>
<ul>
<li><strong>原理</strong>：<code>v-show</code> 是一个指令，它根据表达式的值来控制元素的显示和隐藏。当表达式的值为真时，元素会显示；当表达式的值为假时，元素会隐藏（通过设置 <code>display: none</code> 实现）。</li>
<li><strong>特点</strong>：无论表达式的值是真还是假，元素都会被渲染到 DOM 中，只是通过 CSS 控制其显示与隐藏，因此对性能的影响较小，适用于频繁切换显示状态的元素。</li>
</ul>
</li>
<li><p><strong>v-if</strong>：</p>
<ul>
<li><strong>原理</strong>：<code>v-if</code> 是一个指令，它根据表达式的值来动态添加或移除 DOM 元素。当表达式的值为真时，元素会被添加到 DOM 中；当表达式的值为假时，元素会被从 DOM 中移除。</li>
<li><strong>特点</strong>：根据表达式的值动态添加或移除 DOM 元素，可以减少不必要的 DOM 元素存在，从而节省页面的渲染开销，适用于较少频繁切换显示状态的元素。</li>
</ul>
</li>
</ol>
<p>比较：</p>
<ul>
<li>如果需要频繁切换元素的显示状态，且元素内容较为固定，可以使用 <code>v-show</code>，因为元素会一直存在于 DOM 中，只是显示状态改变；</li>
<li>如果元素的显示状态相对不频繁变化，或者需要在显示和隐藏之间进行大量操作时，可以使用 <code>v-if</code>，因为它能够根据条件动态添加或移除元素，减少不必要的 DOM 元素存在。</li>
</ul>
<p>在实际开发中，开发者可以根据具体的业务需求和页面性能考虑来选择使用 <code>v-show</code> 还是 <code>v-if</code>，以实现最佳的页面渲染效果。</p>
<h1 id="vue-key的基本使用原理"><a href="#vue-key的基本使用原理" class="headerlink" title="vue key的基本使用原理"></a>vue key的基本使用原理</h1><p>在 Vue.js 中，<code>key</code> 是用来帮助 Vue 识别节点的唯一性，并在进行列表渲染时，识别节点的变化，从而进行高效的更新和复用。下面是 <code>key</code> 的基本使用原理：</p>
<ol>
<li><p><strong>节点唯一性</strong>：在进行列表渲染时，Vue 需要保证每个被渲染的节点具有唯一的标识，以便能够正确识别节点的变化。</p>
</li>
<li><p><strong>节点复用</strong>：Vue 在进行列表渲染时，会尽量复用已经存在的节点而不是销毁和重新创建，以提高性能。如果没有 <code>key</code>，Vue 会默认使用节点的索引作为标识，但这可能会导致不必要的 DOM 操作。</p>
</li>
<li><p><strong>更新策略</strong>：当数据源数据发生变化时，Vue 会基于节点的 <code>key</code> 属性进行比对，识别出新增、删除、移动和更新的节点，从而实现高效的 DOM 更新。</p>
</li>
<li><p><strong>动态组件和有状态组件</strong>：在使用动态组件或者有状态组件时，<code>key</code> 属性也是十分重要的，可以确保组件实例的唯一性，避免组件状态混乱。</p>
</li>
</ol>
<p>下面是一个简单的示例，演示了 <code>key</code> 的基本使用原理：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">items</span>: [</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;Item 1&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;Item 2&#x27;</span> &#125;</span></span><br><span class="line"><span class="language-javascript">      ]</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">items</span> = [</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;Item 2 Updated&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;Item 3&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;Item 1 Updated&#x27;</span> &#125;</span></span><br><span class="line"><span class="language-javascript">      ];</span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="number">2000</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，通过给 <code>v-for</code> 循环的元素添加 <code>:key=&quot;item.id&quot;</code>，Vue 将会根据 <code>id</code> 来识别每个元素的唯一性，从而实现高效的列表更新。当数据更新时，Vue 可以根据 <code>key</code> 的值来判断节点的增删改，并做出相应的 DOM 操作。</p>
<p>总之，合理使用 <code>key</code> 可以帮助 Vue 实现高效的列表渲染和更新，确保页面性能和用户体验。</p>
<h1 id="vue-mixin-和-使用场景？"><a href="#vue-mixin-和-使用场景？" class="headerlink" title="vue mixin 和 使用场景？"></a>vue mixin 和 使用场景？</h1><p>在 Vue.js 中，Mixin 是一种可重用的组件选项对象，可以包含任意组件选项，如 <code>data</code>、<code>methods</code>、<code>computed</code> 等，可以被多个组件共享和复用。Mixin 提供了一种将代码抽象化、组件化的方式，让开发者能够更灵活地组织和重用代码。下面是 Mixin 的基本使用和使用场景：</p>
<h3 id="Mixin-的基本使用："><a href="#Mixin-的基本使用：" class="headerlink" title="Mixin 的基本使用："></a>Mixin 的基本使用：</h3><ol>
<li><p><strong>定义 Mixin</strong>：通过创建一个包含 Vue 组件选项的普通 JavaScript 对象来定义一个 Mixin。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个 Mixin</span></span><br><span class="line"><span class="keyword">const</span> myMixin = &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;Hello from Mixin!&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">message</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>应用 Mixin</strong>：在组件定义时使用 <code>mixins</code> 选项引入 Mixin。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在组件中引入 Mixin</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">mixins</span>: [myMixin],</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">greet</span>(); <span class="comment">// 调用 Mixin 中的方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Mixin-的使用场景："><a href="#Mixin-的使用场景：" class="headerlink" title="Mixin 的使用场景："></a>Mixin 的使用场景：</h3><ol>
<li><p><strong>代码复用</strong>：适用于多个组件需要共享相同逻辑和数据的情况，避免重复编写相似代码。</p>
</li>
<li><p><strong>功能扩展</strong>：可以通过 Mixin 扩展组件的功能，增加特定功能、方法或属性。</p>
</li>
<li><p><strong>解耦逻辑</strong>：将组件内部逻辑通过 Mixin 分解为可复用的逻辑单元，使代码更易维护和理解。</p>
</li>
<li><p><strong>跨组件通信</strong>：可通过 Mixin 实现跨组件通信，共享公共数据或方法。</p>
</li>
</ol>
<p>需要注意的是，Mixin 在一定程度上会增加代码的复杂性和难以维护性，因此在使用 Mixin 时需要注意避免过度使用，避免混乱和冲突。此外，当混入的选项包含重复的数据或方法时，组件本身和 Mixin 中的选项会进行合并，如果有冲突，组件选项会覆盖 Mixin 中的选项。</p>
<p>因此，在实际开发中，开发者应根据具体场景合理使用 Mixin，以提高代码复用性和开发效率。</p>
<h1 id="vue-修饰符"><a href="#vue-修饰符" class="headerlink" title="vue 修饰符"></a>vue 修饰符</h1><p>在 Vue.js 中，修饰符是一种用于指定指令特殊行为的方式。修饰符以 <code>.</code> 开头，可用于各种指令，例如 <code>v-model</code>、<code>v-on</code>、<code>v-bind</code> 等。下面是常用的 Vue 修饰符以及它们的作用：</p>
<h3 id="1-v-model-修饰符："><a href="#1-v-model-修饰符：" class="headerlink" title="1. v-model 修饰符："></a>1. <strong>v-model 修饰符</strong>：</h3><ul>
<li><strong>.lazy</strong>：在 <code>input</code> 事件触发时同步输入框的值，默认是在 <code>change</code> 事件触发时同步。</li>
<li><strong>.number</strong>：将输入值转为数字类型。</li>
<li><strong>.trim</strong>：自动过滤首尾空格。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">&quot;message&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">&quot;age&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-v-on-修饰符："><a href="#2-v-on-修饰符：" class="headerlink" title="2. v-on 修饰符："></a>2. <strong>v-on 修饰符</strong>：</h3><ul>
<li><strong>.stop</strong>：阻止事件冒泡。</li>
<li><strong>.prevent</strong>：阻止默认事件。</li>
<li><strong>.once</strong>：事件只触发一次。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.stop</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;handleSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.once</span>=<span class="string">&quot;handleClickOnce&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-v-bind-修饰符："><a href="#3-v-bind-修饰符：" class="headerlink" title="3. v-bind 修饰符："></a>3. <strong>v-bind 修饰符</strong>：</h3><ul>
<li><strong>.prop</strong>：绑定 DOM 属性，而不是 attribute。</li>
<li><strong>.camel</strong>：将绑定的属性名称转为驼峰命名。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src.prop</span>=<span class="string">&quot;imageUrl&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">v-bind:camelCaseProp</span>=<span class="string">&quot;value&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-其它修饰符："><a href="#4-其它修饰符：" class="headerlink" title="4. 其它修饰符："></a>4. <strong>其它修饰符</strong>：</h3><ul>
<li><strong>.native</strong>：监听组件根元素的原生事件。</li>
<li><strong>.sync</strong>：在子组件中使用父组件传递的 prop，同步更新父组件的数据。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">v-on:custom-event.native</span>=<span class="string">&quot;handleCustomEvent&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MyChild</span> <span class="attr">v-bind:my-prop.sync</span>=<span class="string">&quot;parentData&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>修饰符可以根据具体的需求来选择使用，能够方便地处理不同情况下的事件及数据绑定需求。在实际开发中，通过合理使用修饰符，可以简化代码逻辑、提高开发效率。</p>
<h1 id="vue-nextTick-原理和应用场景"><a href="#vue-nextTick-原理和应用场景" class="headerlink" title="vue nextTick 原理和应用场景"></a>vue nextTick 原理和应用场景</h1><p><code>Vue.nextTick</code> 是 Vue.js 提供的一个方法，用于在 DOM 更新之后执行延迟逻辑。它的原理是利用 JavaScript 的事件循环机制，在当前执行栈执行完后，立即执行传入的回调函数，确保在 DOM 更新之后执行。下面是 <code>Vue.nextTick</code> 的原理和应用场景：</p>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><ol>
<li>当 Vue 进行数据更新时，DOM 的更新是异步的。</li>
<li><code>Vue.nextTick</code> 会将传入的回调函数推入微任务队列中，在当前任务执行完成后，立即执行微任务队列中的回调函数。</li>
<li>这样可以确保在 DOM 更新完成后执行回调，以便获取更新后的 DOM 元素状态。</li>
</ol>
<h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><ol>
<li><strong>DOM 更新后操作</strong>：当需要在 DOM 更新之后获取更新后的 DOM 元素状态时，可以使用 <code>Vue.nextTick</code> 来确保获取的是最新状态。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在 DOM 更新后执行操作</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">myElement</span>.<span class="property">scrollTop</span> = <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>异步更新视图</strong>：当需要在下一个 DOM 更新周期执行某些操作时，可以使用 <code>Vue.nextTick</code>，避免直接在当前代码块中操作 DOM，确保操作在下一个更新周期执行。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">&#x27;Updated&#x27;</span>; <span class="comment">// 修改数据</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// DOM 已经更新，执行操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>watcher 回调中操作 DOM</strong>：在 watcher 的回调中操作 DOM 元素时，应该在 <code>Vue.nextTick</code> 中执行，以确保操作在下一个 DOM 更新周期执行。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="title function_">someData</span>(<span class="params">newVal, oldVal</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 在 DOM 更新周期后操作 DOM 元素</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，<code>Vue.nextTick</code> 主要应用于处理 DOM 更新后的一些操作，确保在 DOM 发生更改后执行特定的逻辑，以保证数据和 DOM 的同步和正确性。在上述的场景中，使用 <code>Vue.nextTick</code> 可以避免直接操作 DOM 可能引起的问题，提高代码的稳定性和可维护性。</p>
<h1 id="vue-过滤器"><a href="#vue-过滤器" class="headerlink" title="vue 过滤器"></a>vue 过滤器</h1><p>在 Vue.js 中，过滤器是一种用于处理模板中显示的文本格式化的功能。通过在它们插值绑定表达式中使用管道符 <code>|</code> 来调用，从而对数据进行一些转换。下面是 Vue 过滤器的基本用法和应用场景：</p>
<h3 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h3><ol>
<li><strong>定义过滤器</strong>：使用 <code>Vue.filter</code> 方法定义一个全局过滤器或者在组件的 <code>filters</code> 选项中定义一个局部过滤器。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局过滤器</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&#x27;toUpperCase&#x27;</span>, <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> value.<span class="title function_">toString</span>().<span class="title function_">toUpperCase</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件局部过滶器</span></span><br><span class="line"><span class="attr">filters</span>: &#123;</span><br><span class="line">  <span class="title function_">toLowerCase</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> value.<span class="title function_">toString</span>().<span class="title function_">toLowerCase</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>在模板中使用过滤器</strong>：使用管道符 <code>|</code> 将数据和过滤器名称连接起来。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 全局过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; message | toUpperCase &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 局部过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; message | toLowerCase &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h3><ol>
<li><strong>文本格式化</strong>：用于格式化文本，如大小写转换、日期格式化等。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 字符串大小写转换 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; message | toUpperCase &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; message | toLowerCase &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 日期格式化 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; date | formatDate &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>数据筛选</strong>：用于根据条件过滤数据显示内容。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;item.completed | filterCompleted&quot;</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>价格显示</strong>：用于将数据格式化为价格显示形式。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; price | formatPrice &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>搜索过滤</strong>：用于在搜索框中输入关键字过滤显示内容。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;keyword&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items | filterByKeyword&quot;</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，过滤器并不适用于改变原始数据，而是返回新的处理后的数据。此外，过滤器会在视图更新时执行，因此需要注意性能问题，避免在过滤器中执行过重的逻辑。对于复杂的数据处理，建议在计算属性中处理，而不是过滤器中。</p>
<p>总的来说，Vue 过滤器提供了一种简单的方式来处理模板中的数据显示，使代码更具有可读性和灵活性。在合适的场景下使用过滤器能够提高代码的可维护性和可扩展性。</p>
<h1 id="vue自定义指令"><a href="#vue自定义指令" class="headerlink" title="vue自定义指令"></a>vue自定义指令</h1><p>在 Vue.js 中，自定义指令是一种用于封装 DOM 直接操作和行为的方式。通过自定义指令，你可以在 Vue 应用中封装特定的 DOM 操作、事件处理、动画效果等，并在需要的地方进行复用。下面是关于 Vue 自定义指令的介绍和应用场景：</p>
<h3 id="基本用法：-1"><a href="#基本用法：-1" class="headerlink" title="基本用法："></a>基本用法：</h3><ol>
<li><strong>定义自定义指令</strong>：使用 <code>Vue.directive</code> 方法定义一个全局指令或者在组件的 <code>directives</code> 选项中定义一个局部指令。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局自定义指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">    el.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件局部自定义指令</span></span><br><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">  <span class="attr">colorize</span>: &#123;</span><br><span class="line">    <span class="attr">bind</span>: <span class="keyword">function</span> (<span class="params">el, binding</span>) &#123;</span><br><span class="line">      el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>在模板中使用自定义指令</strong>：通过指令名称在需要的元素上使用自定义指令。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 全局自定义指令 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-focus</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 局部自定义指令 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-colorize</span>=<span class="string">&quot;&#x27;red&#x27;&quot;</span>&gt;</span>Custom Colorized Text<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="生命周期钩子："><a href="#生命周期钩子：" class="headerlink" title="生命周期钩子："></a>生命周期钩子：</h3><ol>
<li><strong>bind</strong>：只调用一次，在指令第一次绑定到元素时调用。</li>
<li><strong>inserted</strong>：被绑定元素插入父节点时调用。</li>
<li><strong>update</strong>：当绑定的元素更新时调用（可能会发生多次）。</li>
<li><strong>componentUpdated</strong>：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li>
<li><strong>unbind</strong>：只调用一次，在指令与元素解绑时调用。</li>
</ol>
<h3 id="应用场景：-2"><a href="#应用场景：-2" class="headerlink" title="应用场景："></a>应用场景：</h3><ol>
<li><strong>处理焦点</strong>：自动聚焦到输入框。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-focus</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>样式控制</strong>：动态控制元素的样式。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-colorize</span>=<span class="string">&quot;&#x27;red&#x27;&quot;</span>&gt;</span>Custom Colorized Text<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>事件处理</strong>：封装复杂的事件处理逻辑。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-longpress:300</span>=<span class="string">&quot;handler&quot;</span>&gt;</span>Long Press Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>动画效果</strong>：封装常见的动画效果。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-slide-up</span>=<span class="string">&quot;&#x27;show&#x27;&quot;</span>&gt;</span>Slide Up Content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>自定义指令提供了一种灵活的方式来封装和复用代码逻辑，使得代码更具可维护性和可扩展性。在合适的场景下使用自定义指令能够减少重复代码，提高代码的整洁度和可读性。需要注意的是，自定义指令应该尽量避免直接操作 DOM，而是更多地应用于行为的封装和抽象。</p>
<h1 id="vue-跨域的几种方式"><a href="#vue-跨域的几种方式" class="headerlink" title="vue 跨域的几种方式"></a>vue 跨域的几种方式</h1><p>在前端开发中，由于浏览器的同源策略（Same-Origin Policy），导致跨域请求时会受到限制。在 Vue.js 应用中，如果需要进行跨域请求，可以通过以下几种方式解决：</p>
<h3 id="1-使用代理服务器"><a href="#1-使用代理服务器" class="headerlink" title="1. 使用代理服务器"></a>1. 使用代理服务器</h3><p>通过配置代理服务器来转发请求，让代理服务器去请求其他域上的资源，然后再将结果返回给前端应用。这种方式可以绕过浏览器的跨域限制，常见的代理服务器有 Nginx、webpack-dev-server、http-proxy-middleware 等。</p>
<h3 id="2-JSONP（跨域资源共享）"><a href="#2-JSONP（跨域资源共享）" class="headerlink" title="2. JSONP（跨域资源共享）"></a>2. JSONP（跨域资源共享）</h3><p>JSONP 是一种利用 <code>&lt;script&gt;</code> 标签的跨域技术，通过在前端动态创建 <code>&lt;script&gt;</code> 标签，将请求发送到其他域上的服务器，并通过约定的回调函数来接收数据。Vue.js 中可以通过第三方库或自定义封装实现 JSONP 请求。</p>
<h3 id="3-CORS（跨域资源共享）"><a href="#3-CORS（跨域资源共享）" class="headerlink" title="3. CORS（跨域资源共享）"></a>3. CORS（跨域资源共享）</h3><p>CORS 是一种浏览器允许跨域请求的机制，服务端需要设置响应头 <code>Access-Control-Allow-Origin</code> 允许指定的域进行跨域请求。在 Vue.js 中，如果后台通过 CORS 协议支持跨域请求，前端就可以直接发起跨域请求。</p>
<h3 id="4-使用-WebSocket"><a href="#4-使用-WebSocket" class="headerlink" title="4. 使用 WebSocket"></a>4. 使用 WebSocket</h3><p>WebSocket 是一种在浏览器和服务器之间进行全双工通信的协议，它不受同源策略限制。在 Vue.js 应用中，可以通过 WebSocket 建立长连接，实现跨域通信。</p>
<h3 id="5-代理后端跨域"><a href="#5-代理后端跨域" class="headerlink" title="5. 代理后端跨域"></a>5. 代理后端跨域</h3><p>将前端应用部署到与后端同一个域下，然后通过后端服务器代理转发请求到不同域上的接口。这样可以实现跨域请求，但是需要配合后端进行配置。</p>
<h3 id="6-使用第三方库"><a href="#6-使用第三方库" class="headerlink" title="6. 使用第三方库"></a>6. 使用第三方库</h3><p>Vue.js 开发中可以使用第三方库如 Axios、jQuery AJAX 等来处理跨域请求，这些库通常已经封装好了处理跨域请求的逻辑，可以方便地在 Vue.js 项目中使用。</p>
<p>在实际开发中，选择合适的跨域解决方案取决于具体的业务需求和后端接口情况。需要根据情况综合考虑安全性、性能、代码复杂度等因素，选择适合项目的跨域解决方案。</p>
<h1 id="vue-SSR-如何实现"><a href="#vue-SSR-如何实现" class="headerlink" title="vue SSR 如何实现"></a>vue SSR 如何实现</h1><p>Vue.js 服务器端渲染（SSR）是指在服务器端将 Vue 组件渲染成 HTML 字符串，然后将这些静态内容发送给浏览器进行展示。这样可以提升页面的首屏加载速度、SEO 友好性以及在搜索引擎爬虫中的表现。</p>
<p>要实现 Vue SSR，需要按照以下步骤进行：</p>
<h3 id="1-配置服务器端环境："><a href="#1-配置服务器端环境：" class="headerlink" title="1. 配置服务器端环境："></a>1. 配置服务器端环境：</h3><ul>
<li>确保服务器支持 Node.js 运行环境。</li>
<li>安装 Vue.js SSR 相关依赖，如 <code>vue-server-renderer</code>。</li>
<li>创建服务器入口文件，通常是一个 Express 或 Koa 服务器。</li>
</ul>
<h3 id="2-创建-Vue-实例："><a href="#2-创建-Vue-实例：" class="headerlink" title="2. 创建 Vue 实例："></a>2. 创建 Vue 实例：</h3><ul>
<li>创建一个带有 <code>export default &#123; render: ... &#125;</code> 导出的 Vue 实例，该实例用于渲染页面。</li>
<li>在模板中包含需要渲染的组件。</li>
</ul>
<h3 id="3-服务端渲染代码编写："><a href="#3-服务端渲染代码编写：" class="headerlink" title="3. 服务端渲染代码编写："></a>3. 服务端渲染代码编写：</h3><ul>
<li>创建一个用于渲染 Vue 实例的工具方法，通常会使用 <code>vue-server-renderer</code> 提供的 <code>createRenderer</code> 方法进行渲染。</li>
<li>将渲染得到的 HTML 字符串返回给客户端。</li>
</ul>
<h3 id="4-服务端路由处理："><a href="#4-服务端路由处理：" class="headerlink" title="4. 服务端路由处理："></a>4. 服务端路由处理：</h3><ul>
<li>为了在服务器端处理路由，需要使用服务器框架提供的路由功能（如 Express 的路由中间件）。</li>
<li>根据客户端请求的 URL，在服务器端匹配路由并渲染对应组件。</li>
</ul>
<h3 id="5-客户端激活："><a href="#5-客户端激活：" class="headerlink" title="5. 客户端激活："></a>5. 客户端激活：</h3><ul>
<li>为了实现客户端和服务器端的同构（即允许代码在两个环境中都运行），需要在客户端对服务端渲染的内容进行激活。</li>
<li>通常使用 <code>vue-router</code> 和 <code>vuex</code> 等工具来在客户端重新创建 Vue 实例，实现与服务器渲染内容的一致性。</li>
</ul>
<h3 id="6-部署和优化："><a href="#6-部署和优化：" class="headerlink" title="6. 部署和优化："></a>6. 部署和优化：</h3><ul>
<li>部署 SSR 应用需要考虑服务器性能、缓存策略等问题。</li>
<li>可以通过预渲染、代码分割、懒加载等方式优化 SSR 应用的性能。</li>
</ul>
<p>实现 Vue SSR 需要一定的技术水平，需要熟悉 Vue.js、Node.js、服务器端开发等技术。Vue 官方提供了文档和示例来帮助开发者快速入门和实践 SSR。如果是初学者，建议先从简单的例子入手，并逐步深入了解 SSR 的原理和实现方式。</p>
<h1 id="Vue3-介绍和新特性"><a href="#Vue3-介绍和新特性" class="headerlink" title="Vue3 介绍和新特性"></a>Vue3 介绍和新特性</h1><p>Vue 3 是 Vue.js 框架的下一个主要版本，带来了许多新特性和改进，旨在提供更好的性能、更好的开发体验和更好的可维护性。以下是 Vue 3 的一些重要新特性和改进：</p>
<h3 id="1-Composition-API-组合式-API："><a href="#1-Composition-API-组合式-API：" class="headerlink" title="1. Composition API 组合式 API："></a>1. Composition API 组合式 API：</h3><ul>
<li>Composition API 是 Vue 3 中最显著的变化之一，它提供了一种基于函数的 API 风格，让组件的逻辑更易于组织和重用。</li>
<li>Composition API 使代码更加模块化，提高了代码的可读性和维护性，同时也更方便进行逻辑复用。</li>
</ul>
<h3 id="2-Teleport-传送门："><a href="#2-Teleport-传送门：" class="headerlink" title="2. Teleport 传送门："></a>2. Teleport 传送门：</h3><ul>
<li>Teleport 允许开发者将子组件在 DOM 中的位置传送到父组件以外的其他地方，比如将弹窗组件渲染到 body 下，避免 CSS 样式层叠问题。</li>
</ul>
<h3 id="3-Fragments-碎片："><a href="#3-Fragments-碎片：" class="headerlink" title="3. Fragments 碎片："></a>3. Fragments 碎片：</h3><ul>
<li>Vue 3 支持使用 Fragments 来返回多个根节点，无需再包裹额外的 div 元素，提高了编码的灵活性和简洁性。</li>
</ul>
<h3 id="4-更好的-TypeScript-支持："><a href="#4-更好的-TypeScript-支持：" class="headerlink" title="4. 更好的 TypeScript 支持："></a>4. 更好的 TypeScript 支持：</h3><ul>
<li>Vue 3 对 TypeScript 的支持更加友好，引入了许多新的类型定义和改进，使得开发者可以更轻松地使用 TypeScript 来开发 Vue 应用。</li>
</ul>
<h3 id="5-新的响应式系统："><a href="#5-新的响应式系统：" class="headerlink" title="5. 新的响应式系统："></a>5. 新的响应式系统：</h3><ul>
<li>Vue 3 使用了一个全新的响应式系统，使得响应式数据的追踪更加高效，减少了不必要的计算和更新，提高了性能。</li>
</ul>
<h3 id="6-更快的渲染性能："><a href="#6-更快的渲染性能：" class="headerlink" title="6. 更快的渲染性能："></a>6. 更快的渲染性能：</h3><ul>
<li>Vue 3 在渲染性能方面进行了优化，比 Vue 2 更快，有更小的体积，提供了更好的性能表现。</li>
</ul>
<h3 id="7-更好的最小化支持："><a href="#7-更好的最小化支持：" class="headerlink" title="7. 更好的最小化支持："></a>7. 更好的最小化支持：</h3><ul>
<li>Vue 3 改进了对 Tree-shaking 的支持，使得可以更容易地最小化构建，减少了包的大小。</li>
</ul>
<h3 id="8-其他改进："><a href="#8-其他改进：" class="headerlink" title="8. 其他改进："></a>8. 其他改进：</h3><ul>
<li>Vue 3 还包括了许多其他的改进和新功能，如更好的 TypeScript 支持、更好的调试工具等，提高了开发者的开发效率和用户体验。</li>
</ul>
<p>总的来说，Vue 3 带来了许多令人兴奋的新特性和改进，让开发者可以更轻松、更高效地开发出高性能、易维护的 Vue 应用。尽管在使用 Vue 3 时需要学习新的 API 和概念，但这些变化都是为了让 Vue 更加现代化、更好用。</p>
<h1 id="SPA是什么-实现方式？"><a href="#SPA是什么-实现方式？" class="headerlink" title="SPA是什么 实现方式？"></a>SPA是什么 实现方式？</h1><p>SPA（Single Page Application 单页面应用）是指在 Web 应用中，整个应用只有一个页面，页面在运行过程中不会重新加载整个页面，而是通过动态加载内容、更新页面数据和 URL 来实现页面的切换和更新。SPA 通过 AJAX 技术与后端服务通信，动态地获取数据并更新页面内容，从而提供更流畅、更快速的用户体验。</p>
<p>SPA 的实现方式通常包括以下几个关键技术和概念：</p>
<h3 id="1-路由管理："><a href="#1-路由管理：" class="headerlink" title="1. 路由管理："></a>1. 路由管理：</h3><ul>
<li>SPA 使用客户端路由管理库（如 Vue Router、React Router 等）来管理页面的导航和 URL 路由。</li>
<li>路由管理器负责根据 URL 地址加载相应的组件，并更新页面内容而无需重新加载整个页面。</li>
</ul>
<h3 id="2-组件化开发："><a href="#2-组件化开发：" class="headerlink" title="2. 组件化开发："></a>2. 组件化开发：</h3><ul>
<li>SPA 使用组件化开发的方式构建页面，将页面拆分为多个组件，每个组件负责特定的功能或展示。</li>
<li>组件化开发可以提高代码复用性、开发效率和模块化管理。</li>
</ul>
<h3 id="3-数据交互："><a href="#3-数据交互：" class="headerlink" title="3. 数据交互："></a>3. 数据交互：</h3><ul>
<li>SPA 通过 AJAX、Fetch 或 WebSocket 等技术与后端服务进行数据交互，获取数据并更新页面内容。</li>
<li>前端框架通常提供状态管理工具（如 Vuex、Redux 等）来管理前端数据，确保数据的一致性和可维护性。</li>
</ul>
<h3 id="4-前端路由实现："><a href="#4-前端路由实现：" class="headerlink" title="4. 前端路由实现："></a>4. 前端路由实现：</h3><ul>
<li>SPA 使用前端路由来实现页面之间的跳转和导航，常见的方式是通过 Hash 路由或 HTML5 History API。</li>
<li>前端路由可以实现页面的无刷新切换、前进后退功能，并确保 URL 可分享和可收藏。</li>
</ul>
<h3 id="5-懒加载和代码拆分："><a href="#5-懒加载和代码拆分：" class="headerlink" title="5. 懒加载和代码拆分："></a>5. 懒加载和代码拆分：</h3><ul>
<li>为了提高页面加载速度和性能，SPA 可以使用懒加载技术和代码拆分来延迟加载部分组件和资源。</li>
<li>懒加载可以在需要时再加载页面内容，减小首屏加载体积，提升用户体验。</li>
</ul>
<p>通过以上技术和实践，SPA 能够提供更加流畅和响应快速的用户体验，同时也有利于前后端分离、提升开发效率和代码可维护性。然而，SPA 也需要考虑 SEO、路由管理、性能优化等方面的挑战和解决方案。</p>
<h1 id="SPA-首屏加载优化方案"><a href="#SPA-首屏加载优化方案" class="headerlink" title="SPA 首屏加载优化方案"></a>SPA 首屏加载优化方案</h1><p>对于单页面应用（SPA）的首屏加载优化是提升用户体验和页面性能的关键，以下是一些常用的优化方案：</p>
<h3 id="1-代码拆分（Code-Splitting）："><a href="#1-代码拆分（Code-Splitting）：" class="headerlink" title="1. 代码拆分（Code Splitting）："></a>1. 代码拆分（Code Splitting）：</h3><ul>
<li>使用代码拆分技术，将页面代码分割为多个小块，并在需要时按需加载，减少首屏加载的体积和加载时间。</li>
<li>常用工具如 Webpack 提供的 SplitChunksPlugin 或动态 import() 函数可以实现代码拆分。</li>
</ul>
<h3 id="2-懒加载（Lazy-Loading）："><a href="#2-懒加载（Lazy-Loading）：" class="headerlink" title="2. 懒加载（Lazy Loading）："></a>2. 懒加载（Lazy Loading）：</h3><ul>
<li>将某些不必要在首屏加载的模块或组件延迟加载，可以使用 Vue Router 或 React Router 提供的懒加载功能实现。</li>
<li>只在用户需要时再加载相关资源，减少首屏加载时间和消耗。</li>
</ul>
<h3 id="3-骨架屏（Skeleton-Screen）："><a href="#3-骨架屏（Skeleton-Screen）：" class="headerlink" title="3. 骨架屏（Skeleton Screen）："></a>3. 骨架屏（Skeleton Screen）：</h3><ul>
<li>使用骨架屏技术，提供一个简单的页面骨架结构，先展示页面布局和加载状态，然后再加载真实内容，减少白屏时间。</li>
<li>让用户感知到页面正在加载，并提升用户体验。</li>
</ul>
<h3 id="4-预渲染（Pre-rendering）："><a href="#4-预渲染（Pre-rendering）：" class="headerlink" title="4. 预渲染（Pre-rendering）："></a>4. 预渲染（Pre-rendering）：</h3><ul>
<li>对关键页面进行预渲染，将页面提前生成为静态 HTML 文件，然后进行缓存和预加载。</li>
<li>在某些情况下，预渲染可以加速首屏加载速度，提高用户体验。</li>
</ul>
<h3 id="5-图片优化："><a href="#5-图片优化：" class="headerlink" title="5. 图片优化："></a>5. 图片优化：</h3><ul>
<li>对页面中的图片进行优化，包括使用适当的图片格式、压缩图片大小等方式，减少图片加载时间和带宽消耗。</li>
<li>懒加载图片以及使用响应式图片等技术也可以提升首屏加载速度。</li>
</ul>
<h3 id="6-延迟加载（Lazy-Load）："><a href="#6-延迟加载（Lazy-Load）：" class="headerlink" title="6. 延迟加载（Lazy Load）："></a>6. 延迟加载（Lazy Load）：</h3><ul>
<li>将部分非关键资源（如广告、社交分享插件等）延迟加载，等页面主要内容加载完成后再加载这些资源。</li>
<li>避免阻塞主要内容的加载，提高首屏加载速度。</li>
</ul>
<h3 id="7-CDN-加速："><a href="#7-CDN-加速：" class="headerlink" title="7. CDN 加速："></a>7. CDN 加速：</h3><ul>
<li>使用 CDN（内容分发网络）加速静态资源的加载，减少网络延迟和提高资源加载速度。</li>
<li>将静态文件（如 CSS、JavaScript、图片等）部署在全球各地的 CDN 节点上，加速资源加载。</li>
</ul>
<p>综合利用以上的优化方案，可以有效地提升单页面应用的首屏加载速度和用户体验。不同项目和场景可能适用不同的优化策略，建议根据具体情况选择合适的方案进行优化。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://zej574099903.github.io">皮蛋瘦肉周</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://zej574099903.github.io/2023/02/26/vue/">https://zej574099903.github.io/2023/02/26/vue/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zej574099903.github.io" target="_blank">Code Chronicles</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/vue.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2024/02/23/react/" title="react"><img class="cover" src="/img/loading.gif" data-original="/img/react.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">react</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">皮蛋瘦肉周</div><div class="author-info__description">Welcome to Jhon's Home</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zej574099903/zej574099903.github.io"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://githubfast.com/lyr233" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/YR_112233" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=728831102&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:728831102@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E4%B8%8B%E5%AF%B9vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">描述下对vue生命周期的理解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="toc-number">2.</span> <span class="toc-text">双向数据绑定</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E6%94%B6%E9%9B%86%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">双向收集是如何实现的？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">vue组件通信方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue-data%E7%9A%84%E5%B1%9E%E6%80%A7%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">vue data的属性为什么是一个函数而不是对象？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#v-show-v-if%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">6.</span> <span class="toc-text">v-show v-if的原理分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue-key%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">vue key的基本使用原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue-mixin-%E5%92%8C-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">vue mixin 和 使用场景？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mixin-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">8.0.1.</span> <span class="toc-text">Mixin 的基本使用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mixin-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">8.0.2.</span> <span class="toc-text">Mixin 的使用场景：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">9.</span> <span class="toc-text">vue 修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-v-model-%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9A"><span class="toc-number">9.0.1.</span> <span class="toc-text">1. v-model 修饰符：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-v-on-%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9A"><span class="toc-number">9.0.2.</span> <span class="toc-text">2. v-on 修饰符：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-v-bind-%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9A"><span class="toc-number">9.0.3.</span> <span class="toc-text">3. v-bind 修饰符：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%85%B6%E5%AE%83%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9A"><span class="toc-number">9.0.4.</span> <span class="toc-text">4. 其它修饰符：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue-nextTick-%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">10.</span> <span class="toc-text">vue nextTick 原理和应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">10.0.1.</span> <span class="toc-text">原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">10.0.2.</span> <span class="toc-text">应用场景：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue-%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">11.</span> <span class="toc-text">vue 过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%EF%BC%9A"><span class="toc-number">11.0.1.</span> <span class="toc-text">基本用法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A-1"><span class="toc-number">11.0.2.</span> <span class="toc-text">应用场景：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-number">12.</span> <span class="toc-text">vue自定义指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%EF%BC%9A-1"><span class="toc-number">12.0.1.</span> <span class="toc-text">基本用法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%EF%BC%9A"><span class="toc-number">12.0.2.</span> <span class="toc-text">生命周期钩子：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A-2"><span class="toc-number">12.0.3.</span> <span class="toc-text">应用场景：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue-%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">13.</span> <span class="toc-text">vue 跨域的几种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">13.0.1.</span> <span class="toc-text">1. 使用代理服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JSONP%EF%BC%88%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%89"><span class="toc-number">13.0.2.</span> <span class="toc-text">2. JSONP（跨域资源共享）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-CORS%EF%BC%88%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%89"><span class="toc-number">13.0.3.</span> <span class="toc-text">3. CORS（跨域资源共享）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8-WebSocket"><span class="toc-number">13.0.4.</span> <span class="toc-text">4. 使用 WebSocket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BB%A3%E7%90%86%E5%90%8E%E7%AB%AF%E8%B7%A8%E5%9F%9F"><span class="toc-number">13.0.5.</span> <span class="toc-text">5. 代理后端跨域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93"><span class="toc-number">13.0.6.</span> <span class="toc-text">6. 使用第三方库</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue-SSR-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">14.</span> <span class="toc-text">vue SSR 如何实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%8E%AF%E5%A2%83%EF%BC%9A"><span class="toc-number">14.0.1.</span> <span class="toc-text">1. 配置服务器端环境：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA-Vue-%E5%AE%9E%E4%BE%8B%EF%BC%9A"><span class="toc-number">14.0.2.</span> <span class="toc-text">2. 创建 Vue 实例：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%EF%BC%9A"><span class="toc-number">14.0.3.</span> <span class="toc-text">3. 服务端渲染代码编写：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%A4%84%E7%90%86%EF%BC%9A"><span class="toc-number">14.0.4.</span> <span class="toc-text">4. 服务端路由处理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%BF%80%E6%B4%BB%EF%BC%9A"><span class="toc-number">14.0.5.</span> <span class="toc-text">5. 客户端激活：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%83%A8%E7%BD%B2%E5%92%8C%E4%BC%98%E5%8C%96%EF%BC%9A"><span class="toc-number">14.0.6.</span> <span class="toc-text">6. 部署和优化：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue3-%E4%BB%8B%E7%BB%8D%E5%92%8C%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">15.</span> <span class="toc-text">Vue3 介绍和新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Composition-API-%E7%BB%84%E5%90%88%E5%BC%8F-API%EF%BC%9A"><span class="toc-number">15.0.1.</span> <span class="toc-text">1. Composition API 组合式 API：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Teleport-%E4%BC%A0%E9%80%81%E9%97%A8%EF%BC%9A"><span class="toc-number">15.0.2.</span> <span class="toc-text">2. Teleport 传送门：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Fragments-%E7%A2%8E%E7%89%87%EF%BC%9A"><span class="toc-number">15.0.3.</span> <span class="toc-text">3. Fragments 碎片：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9B%B4%E5%A5%BD%E7%9A%84-TypeScript-%E6%94%AF%E6%8C%81%EF%BC%9A"><span class="toc-number">15.0.4.</span> <span class="toc-text">4. 更好的 TypeScript 支持：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%96%B0%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%9A"><span class="toc-number">15.0.5.</span> <span class="toc-text">5. 新的响应式系统：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%9B%B4%E5%BF%AB%E7%9A%84%E6%B8%B2%E6%9F%93%E6%80%A7%E8%83%BD%EF%BC%9A"><span class="toc-number">15.0.6.</span> <span class="toc-text">6. 更快的渲染性能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8C%96%E6%94%AF%E6%8C%81%EF%BC%9A"><span class="toc-number">15.0.7.</span> <span class="toc-text">7. 更好的最小化支持：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%85%B6%E4%BB%96%E6%94%B9%E8%BF%9B%EF%BC%9A"><span class="toc-number">15.0.8.</span> <span class="toc-text">8. 其他改进：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SPA%E6%98%AF%E4%BB%80%E4%B9%88-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">SPA是什么 实现方式？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86%EF%BC%9A"><span class="toc-number">16.0.1.</span> <span class="toc-text">1. 路由管理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%EF%BC%9A"><span class="toc-number">16.0.2.</span> <span class="toc-text">2. 组件化开发：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%EF%BC%9A"><span class="toc-number">16.0.3.</span> <span class="toc-text">3. 数据交互：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">16.0.4.</span> <span class="toc-text">4. 前端路由实现：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%BB%A3%E7%A0%81%E6%8B%86%E5%88%86%EF%BC%9A"><span class="toc-number">16.0.5.</span> <span class="toc-text">5. 懒加载和代码拆分：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SPA-%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-number">17.</span> <span class="toc-text">SPA 首屏加载优化方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81%E6%8B%86%E5%88%86%EF%BC%88Code-Splitting%EF%BC%89%EF%BC%9A"><span class="toc-number">17.0.1.</span> <span class="toc-text">1. 代码拆分（Code Splitting）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%88Lazy-Loading%EF%BC%89%EF%BC%9A"><span class="toc-number">17.0.2.</span> <span class="toc-text">2. 懒加载（Lazy Loading）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%AA%A8%E6%9E%B6%E5%B1%8F%EF%BC%88Skeleton-Screen%EF%BC%89%EF%BC%9A"><span class="toc-number">17.0.3.</span> <span class="toc-text">3. 骨架屏（Skeleton Screen）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%A2%84%E6%B8%B2%E6%9F%93%EF%BC%88Pre-rendering%EF%BC%89%EF%BC%9A"><span class="toc-number">17.0.4.</span> <span class="toc-text">4. 预渲染（Pre-rendering）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96%EF%BC%9A"><span class="toc-number">17.0.5.</span> <span class="toc-text">5. 图片优化：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%88Lazy-Load%EF%BC%89%EF%BC%9A"><span class="toc-number">17.0.6.</span> <span class="toc-text">6. 延迟加载（Lazy Load）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-CDN-%E5%8A%A0%E9%80%9F%EF%BC%9A"><span class="toc-number">17.0.7.</span> <span class="toc-text">7. CDN 加速：</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/02/23/react/" title="react"><img src="/img/loading.gif" data-original="/img/react.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="react"/></a><div class="content"><a class="title" href="/2024/02/23/react/" title="react">react</a><time datetime="2024-02-23T07:15:55.000Z" title="发表于 2024-02-23 15:15:55">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/26/vue/" title="vue"><img src="/img/loading.gif" data-original="/img/vue.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vue"/></a><div class="content"><a class="title" href="/2023/02/26/vue/" title="vue">vue</a><time datetime="2023-02-26T09:14:03.000Z" title="发表于 2023-02-26 17:14:03">2023-02-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/vue_top.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 皮蛋瘦肉周</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>